import './style.css'
// Комментарий
// alert('Я JS')
console.log('Я JS') // выводит в консоль "Я JS"

console.log(1 +
  2 +
  4)

// ; ставится только перед квадратными скобками
;[1, 2].forEach(console.log)

/*
  Многострочный
  комментарий
*/

// Многострочный
// комментарий

// Объявили переменную m и присвоили ей значение 1 
let m = 1

// объявили несколько переменных через запятую
// let user = 'John', age = 25, message = 'Hello'
// Но лучше определять переменные на новой строке
let user = 'John'
let age = 25
let message = 'Hello'
console.log('значение переменной user', user)
user = 'Kate'
console.log('значение переменной user', user)
console.log('значение переменной age', age)
console.log('значение переменной message', message)


let hello = 'Hello world!'

// копируем значение 'Hello world' из переменной hello в переменную message
message = hello

// теперь две переменные содержат одинаковые данные
console.log('значение переменной hello', hello) // Hello world!
console.log('значение переменной message', message) // Hello world!

// Невозможно повторно объявить переменную "hello" с областью видимости "Блок"
// let hello

// При обращении к переменной, которая не была создана при помощи let, движок
// пытается найти её в коде выше, и если не находит, выводится ошибка
// Не удается найти имя "newVar"
// newVar = 10

// !Имена переменных
// В JavaScript есть два ограничения, касающиеся имён переменных:

// !Имя переменной должно содержать только буквы, цифры или символы $ и _.
// !Первый символ не должен быть цифрой.
// Примеры допустимых имён:

let userName
let test123
// Если имя содержит несколько слов, обычно используется верблюжья нотация, то есть, слова следуют одно за другим, где каждое следующее слово начинается с заглавной буквы: myVeryLongName.
// Самое интересное – знак доллара '$' и подчёркивание '_' также можно использовать в названиях.Это обычные символы, как и буквы, без какого - либо особого значения.
// Эти имена являются допустимыми:

let $ = 1; // объявили переменную с именем "$"
let _ = 2; // а теперь переменную с именем "_"

console.log($ + _); // 3

// Создали переменную, имя которой начинается на число
// Идентификатор или ключевое слово не может следовать непосредственно за числовым литералом
// let 1a // не может начинаться с цифры
// let my-name // дефис '-' не разрешён в имени (возпринимается как минус)

// Регистр имеет значение
// Переменные с именами apple и APPLE – это две разные переменные.

// Нелатинские буквы разрешены, но не рекомендуются
// Можно использовать любой язык, включая кириллицу или даже иероглифы, например:

let имя = '...'
let 我 = '...'


// !Зарезервированные имена
// Существует список зарезервированных слов, которые нельзя использовать в качестве имён переменных, потому что они используются самим языком.

// Например: let, class, return и function зарезервированы.

// Приведённый ниже код даёт синтаксическую ошибку:

// let let = 5; // нельзя назвать переменную "let", ошибка!
// let return = 5; // также нельзя назвать переменную "return", ошибка!

// Константы
// Чтобы объявить константную, то есть, неизменяемую переменную, используйте const вместо let:

// Объявления "const" должны быть инициализированы (Должно быть присвоено значение)
// const myBirthday1

const myBirthday = '18.04.1982'
$ = 5
// Не удается задать значение для "myBirthday", так как это константа
// myBirthday = ''

// Константы в верхнем регистре
// Широко распространена практика использования констант в качестве псевдонимов для трудно запоминаемых значений, которые известны до начала исполнения скрипта.

// Названия таких констант пишутся с использованием заглавных букв и подчёркивания.

// Например, сделаем константы для различных цветов в «шестнадцатеричном формате»:

const COLOR_RED = "#F00"
const COLOR_GREEN = "#0F0"
const COLOR_BLUE = "#00F"
const COLOR_ORANGE = "#FF7F00"

// ...когда нам нужно выбрать цвет
let color = COLOR_ORANGE
console.log('color',color) // #FF7F00


// !Типы данных
// Значение в JavaScript всегда относится к данным определённого типа.Например, это может быть строка или число.

// Есть восемь основных типов данных в JavaScript.В этой главе мы рассмотрим их в общем, а в следующих главах поговорим подробнее о каждом.

// Когда мы присвоили какое-то значение переменной, тип этого значения сразу привязался к переменной
// Произошла неявная запись 
// let string:string = 'fsddfg'
let string = 'fsddfg'

// имяПеременной:any - такая запись говорит о том, что мы хотим, чтобы переменная хранила любое значение
let newMessage:any = "hello"
// либо мы можем указать после значения переменной as any
let newMessage2 = "hello" as any
newMessage = 123456
newMessage2 = 465

// !Число
let n = 123
n = 12.345
console.log('1_000_000', 1_000_000)
console.log('10e3', 10e3) // e3 == 10**3
console.log('1e-3', 1e-3) // e3 == 10**-3

console.log('typeof(n)', typeof(n)) // number
// Числовой тип данных(number) представляет как целочисленные значения, так и числа с плавающей точкой.

// Существует множество операций для чисел, например, умножение *, деление /, сложение +, вычитание - и так далее.

// Кроме обычных чисел, существуют так называемые «специальные числовые значения», которые относятся к этому типу данных: Infinity, -Infinity и NaN.

// Infinity представляет собой математическую бесконечность ∞. Это особое значение, которое больше любого числа.

// Мы можем получить его в результате деления на ноль:

console.log(1 / 0); // Infinity
// Или задать его явно:

console.log(Infinity); // Infinity
// NaN означает вычислительную ошибку.Это результат неправильной или неопределённой математической операции, например:

console.log(("не число" as any) / 2); // NaN, такое деление является ошибкой
// Значение NaN «прилипчиво». Любая математическая операция с NaN возвращает NaN:

console.log(NaN + 1); // NaN
console.log(3 * NaN); // NaN
// @ts-ignore
console.log("не число" / 2 - 1) // NaN
// Если где - то в математическом выражении есть NaN, то оно распространяется на весь результат(есть только одно исключение: NaN ** 0 равно 1).

// !символ "n" в конце означает, что это BigInt
const bigInt = 1234567890123456789012345678901234567890n
console.log('typeof(bigInt)', typeof (bigInt)) // bigint

// !Строка
// Строка (string) в JavaScript должна быть заключена в кавычки.

let str = "Привет dfssdf"
console.log('typeof(str)', typeof (str)) // string
// Предпочтительнее использовать одинарные либо косые кавычки для строк
// Для использования переноса строки в обычной строке, мы можем использовать специальный командный символ
// \n

// Обратная косая черта используется в паре с каким либо знаком в 2х вариантах: для экранирования или передачи командного символа

console.log('Строка с экранированной одинарной кавычкой', '\'')
console.log('Строка с экранированной двойной кавычкой', "\"str\"")
console.log('Обычная строка с\nпереносом строки и\tтабуляцией')

let str2 = 'Одинарные \r\n"кавычки" тоже подойдут It\'s'
// Строки с косыми кавычками поддерживаю перенос строки, а так же позволяют встраивать в себя значения переменных
// Их так же называют шаблонными строками
let phrase = `Обратные ${2+3}
'кавычки' позволяют 
"встраивать" переменные ${str}`



console.log('str2', str2)
console.log('phrase', phrase)

let name = 'Женя'
age = 23

// Такое встраивание хначений в строку называется интерполяцией
console.log(`Привет, меня зовут ${name}.
Мне ${age} лет.
Через месяц мне будет ${age+1}`)

// Объявление пустой строки
let emptyString = ''

// !Булевый(логический) тип
// Булевый тип(boolean) может принимать только два значения: true(истина) и false(ложь).

// Такой тип, как правило, используется для хранения значений да / нет: true значит «да, правильно», а false значит «нет, не правильно».

let nameFieldChecked = true // да, поле отмечено
let ageFieldChecked = false // нет, поле не отмечено
// Булевые значения также могут быть результатом сравнений:

console.log('4 > 1', 4 > 1)
// @ts-ignore
console.log('4 == 2', 4 == 2)
console.log('typeof(true)', typeof (true)) // boolean

// !Значение «null»
// Специальное значение null не относится ни к одному из типов, описанных выше.

// Оно формирует отдельный тип, который содержит только значение null:

let newAge = null
// Тип значения null - null, но typeof возвращает object. Это ошибка typeof, ведущая начало с времён создания JavaScript и сохранённая для совместимости
console.log('typeof(null)', typeof (null)) // object
// В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках.

// Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».

// В приведённом выше коде указано, что значение переменной age неизвестно.

// !Значение «undefined»
// Специальное значение undefined также стоит особняком.Оно формирует тип из самого себя так же, как и null.

// Оно означает, что «значение не было присвоено».

// Если переменная объявлена, но ей не присвоено никакого значения, то её значением будет undefined:

let ageN

console.log(ageN) // выведет "undefined"
// Технически мы можем присвоить значение undefined любой переменной:

ageN = 123

// изменяем значение на undefined
ageN = undefined

console.log(ageN) // "undefined"
console.log('typeof(undefined)', typeof (undefined)) // undefined
// …Но так делать не рекомендуется.Обычно null используется для присвоения переменной «пустого» или «неизвестного» значения, а undefined – для проверок, была ли переменная назначена.

// !Объекты и символы
// Тип object(объект) – особенный.
console.log('typeof({})', typeof ({})) // object
// Все остальные типы называются «примитивными», потому что их значениями могут быть только простые значения(будь то строка, или число, или что - то ещё).В объектах же хранят коллекции данных или более сложные структуры.

// Объекты занимают важное место в языке и требуют особого внимания.Мы разберёмся с ними в главе Объекты после того, как узнаем больше о примитивах.

// Тип symbol(символ) используется для создания уникальных идентификаторов в объектах.Мы упоминаем здесь о нём для полноты картины, изучим этот тип после объектов.
console.log('typeof(Symbol("id"))', typeof Symbol('id')) // symbol

// Функция не является отдельным типом данных, но typeof возвращает для неё значение function
console.log('typeof(alert)', typeof alert) // function

// В JavaScript есть 8 основных типов данных.

// Семь из них называют «примитивными» типами данных:
// number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253 - 1).
// bigint для целых чисел произвольной длины.
// string для строк.Строка может содержать ноль или больше символов, нет отдельного символьного типа.
// boolean для true / false.
// null для неизвестных значений – отдельный тип, имеющий одно значение null.
// undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.
// symbol для уникальных идентификаторов.
// И один не является «примитивным» и стоит особняком:
// object для более сложных структур данных.
// Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.

// Имеет две формы: typeof x или typeof (x).
// Возвращает строку с именем типа.Например, "string".
// Для null возвращается "object" – это ошибка в языке, на самом деле это не объект.

// !!!Литералы JavaScript - это фиксированное значение, которое нельзя изменить, вам не нужно указывать какой - либо тип ключевого слова для записи литералов. Литералы часто используются для инициализации переменных в программировании, имена переменных являются строковыми литералами.

let num = 132

// функция alert выводит сообщение на экран, блокируя отображение
// функция prompt запрашивает у пользователя, блокируя отображение
// !Любой пользовательский ввод - это всегда строка!
// !Чтобы преобразовать строку в число, неободимо сделать преобразование
// parseInt - функция, которая достаёт целое число из строки, если эта строка начинается на число
// let input = parseInt(prompt('Введите число','0') as string)

// parseFloat - функция, которая достаёт число c плавающей запятой из строки, если эта строка начинается на число

// 1 Запросите у пользователя число, возведите это число во 2 - ю степень и выведите на экран.
// let input = parseFloat(prompt('Введите число','0') as string)
// alert(`sum ${input-input}
// div ${input+input}`)

// Показывает пользователю текст сообщения, на что пользователь может нажать ОК или отмена
// Если пользователь нажал ОК, возвращает true
// Если пользователь нажал отмена, возвращает false
// confirm('текст сообщения')

// !Преобразование значений примитивов
// ?Строковое преобразование

let value = true
console.log('typeof true',typeof value) // boolean

// функция String(value), преобразует значение к строке

let strValue = String(value) // теперь value это строка "true"
console.log('typeof "true"', typeof strValue) // string
console.log('String(1)', String(1))
console.log('String(null)', String(null))
console.log('String(undefined)', String(undefined))

// ?Численное преобразование

// !Численное преобразование происходит в математических функциях и выражениях.

// Например, когда операция деления / применяется не к числу:

// Операции, которые всегда неявно приводят операнды к числу, получаем число
// TS ругается, когда мы пытаемся делить строки
// @ts-ignore
console.log('"6" / "2"',"6" / "2") // 3, строки преобразуются в числа
// @ts-ignore
console.log('"6" * "2" =', "6" * "2") // 12
// @ts-ignore
console.log('"6" ** "2" =', "6" ** "2") // 36
// @ts-ignore  
console.log('"6" % "2" =', "6" % "2") // 6 на 2 делится целиком, остаток 0
// @ts-ignore  % - остаток от целочисленного деления
console.log('"7" % "2" =', "7" % "2") // 1
// @ts-ignore
console.log('"7.5" % "2" =', "7.5" % "2") // 1
// @ts-ignore
console.log('"6" - "2" =', "6" - "2") // 4


// Сложение строк называется конкатенацией. Эта поерация склеивает две строки в одну
console.log('"6" + "2" =', "6" + "2") // '62'
console.log('"6" + 2 =', "6" + 2) // '62'
console.log('6 + "2" =', 6 + "2") // '62'
// Операции сложения происходят слева на право
console.log('8 + 6 + "2" =', 8 + 6 + "2") // '142'
// Скобки имеют высший приоритет
console.log('"1" + (8 + 6) + "2" =',"1" + (8 + 6) + "2") // '1142'


// Мы можем использовать функцию Number(value), чтобы явно преобразовать value к числу:

str = "123"
console.log(typeof str) // string

num = Number(str) // становится числом 123

console.log(typeof num) // number

console.log('Number("1")', Number("1"))             // 1
console.log('Number("1(one)")', Number("1(one)"))   // NaN
console.log('Number(null)', Number(null))           // 0
console.log('Number(undefined)', Number(undefined)) // NaN

// Правила численного преобразования:

// Значение	Преобразуется в…
// undefined	NaN
// null	0
// true / false	1 / 0
// string	Пробельные символы(пробелы, знаки табуляции \t, знаки новой строки \n и т.п.) по краям обрезаются.
// Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число.
// При ошибке результат NaN.

console.log('Number("   123   ")', Number("   123   ")) // 123
console.log('Number("   \n\t   ")', Number("   \n\t   ")) // 0
console.log('Number("")', Number("")) // 0
console.log('Number("123z")', Number("123z"))      // NaN (ошибка чтения числа на месте символа "z")
console.log('Number(true)', Number(true))        // 1
console.log('Number(false)', Number(false))       // 0

// Короткая запись преобразования к числу
console.log('+true', +true)        // 1
console.log('+"2"', +"2")          // 2

console.log('3 + +"2"', 3 + +"2")  // 5
console.log('3 + Number("2")', 3 + Number("2"))  // 5

// ?Логическое преобразование

// Правило преобразования:

// Значения, которые интуитивно «пустые», вроде 0, пустой строки, null, undefined и NaN, становятся false.
// Все остальные значения становятся true

// !!! Здесь предствлены все значения, которые преобразуются к false
console.log('Здесь предствлены все значения, которые преобразуются к false')
console.log('Boolean(0)', Boolean(0)) // false
console.log('Boolean("")', Boolean("")) // false
console.log('Boolean(null)', Boolean(null)) // false
console.log('Boolean(undefined)', Boolean(undefined)) // false
console.log('Boolean(NaN)', Boolean(NaN)) // false

console.log('Boolean(-10)', Boolean(-10)) // true

console.log('Boolean("Привет!")', Boolean("Привет!")) // true
// Заметим, что строчка с нулём "0" — это true
// Некоторые языки(к примеру, PHP) воспринимают строку "0" как false.Но в JavaScript, если строка не пустая, то она всегда true.
// !!! Строка с пробелом и стока с нулём
console.log('Boolean("0")', Boolean("0")) // true
console.log('Boolean(" ")', Boolean(" ")) // пробел это тоже true (любая непустая строка это true)

// Короткая запись преобразования к булеву
console.log('!!" "', !!" ") // !! - двойное отрицание, краткая запись приведения к булеву

// Оператор ! и операция отрицания
console.log('!true', !true) // false 
console.log('!false', !false) // true
console.log('!0', !0) // true

// Термины: «унарный», «бинарный», «операнд»
// Прежде, чем мы двинемся дальше, давайте разберёмся с терминологией.

// Операнд – то, к чему применяется оператор.Например, в умножении 5 * 2 есть два операнда: левый операнд равен 5, а правый операнд равен 2. Иногда их называют «аргументами» вместо «операндов».

// Унарным называется оператор, который применяется к одному операнду.Например, оператор унарный минус "-" меняет знак числа на противоположный:

let x = 1

x = -x
console.log(x) // -1, применили унарный минус
// Бинарным называется оператор, который применяется к двум операндам.Тот же минус существует и в бинарной форме:

x = 1
let y = 3
console.log(y - x) // 2, бинарный минус вычитает значения
// Формально, в последних примерах мы говорим о двух разных операторах, использующих один символ: оператор отрицания(унарный оператор, который обращает знак) и оператор вычитания(бинарный оператор, который вычитает одно число из другого)

// Взятие остатка %
// Оператор взятия остатка %, несмотря на обозначение, никакого отношения к процентам не имеет.

// Результат a % b – это остаток от целочисленного деления a на b.

console.log(5 % 2) // 1, остаток от деления 5 на 2
console.log(8 % 3) // 2, остаток от деления 8 на 3
console.log(8 % 4) // 0, остаток от деления 8 на 4

// Математически, оператор работает и для нецелых чисел.Например, квадратный корень является возведением в степень 1 / 2:

console.log(4 ** (1 / 2)) // 2 (степень 1/2 эквивалентна взятию квадратного корня)
console.log(8 ** (1 / 3)) // 2 (степень 1/3 эквивалентна взятию кубического корня)

// ?Сокращённая арифметика с присваиванием

n = 2
n += 5 // теперь n = 7 (работает как n = n + 5)
n *= 2 // теперь n = 14 (работает как n = n * 2)
n /= 2 // теперь n = 7 (работает как n = n / 2)
n = 5 // теперь n = 2 (работает как n = n - 5)
n **= 2 // теперь n = 4 (работает как n = n ** 2)
n %= 3 // теперь n = 1 (работает как n = n % 3 )

// Инкремент / декремент
// Одной из наиболее частых числовых операций является увеличение или уменьшение на единицу.

// Для этого существуют даже специальные операторы:

// Инкремент++ увеличивает переменную на 1:

let counter = 2
counter++             // работает как counter = counter + 1, просто запись короче
console.log(counter)  // 3
// Декремент-- уменьшает переменную на 1:

counter = 2
counter--            // работает как counter = counter - 1, просто запись короче
console.log(counter) // 1

// !Инкремент / декремент можно применить только к переменной.Попытка использовать его на значении, типа 5++, приведёт к ошибке.

// Операторы++ и-- могут быть расположены не только после, но и до переменной.

// Когда оператор идёт после переменной — это «постфиксная форма»: counter++.
// «Префиксная форма» — это когда оператор идёт перед переменной: ++counter.
// Обе эти инструкции делают одно и то же: увеличивают counter на 1.

// Есть ли разница между ними ? Да, но увидеть её мы сможем, только если будем использовать значение, которое возвращают++ / --.

// Давайте проясним этот момент.Как мы знаем, все операторы возвращают значение.Операторы инкремента / декремента не исключение.Префиксная форма возвращает новое значение, в то время как постфиксная форма возвращает старое(до увеличения / уменьшения числа).

// Чтобы увидеть разницу, вот небольшой пример:

// Префиксная форма возвращает новое значение
counter = 1
console.log('counter = 1')
console.log('++counter', ++counter)
console.log('counter', counter)

// Постфиксная форма возвращает старое значение
counter = 1
console.log('counter = 1')
console.log('counter++', counter++)
console.log('counter', counter)

// !Если результат оператора не используется, а нужно только увеличить/уменьшить переменную, тогда без разницы, какую форму использовать. Обычно используется именно так

counter++

// let a = +(prompt("Первое число?", '1') as string)
//     a = Number(prompt("Первое число?", '1'))
//     a = parseInt(prompt("Первое число?", '1') as string)
//     a = parseFloat(prompt("Первое число?", '1') as string)

// !Операторы сравнения
// Многие операторы сравнения известны нам из математики.

// В JavaScript они записываются так:

// Больше / меньше: a > b, a < b.
// Больше / меньше или равно: a >= b, a <= b.
// Равно: a == b.Обратите внимание, для сравнения используется двойной знак равенства ==.Один знак равенства a = b означал бы присваивание.
// Не равно.В математике обозначается символом ≠, но в JavaScript записывается как a != b.
// В этом разделе мы больше узнаем про то, какие бывают сравнения, как язык с ними работает и к каким неожиданностям мы должны быть готовы.

// Результат сравнения имеет логический тип
// Все операторы сравнения возвращают значение логического типа:

// true – означает «да», «верно», «истина».
// false – означает «нет», «неверно», «ложь».

console.log('2 > 1', 2 > 1)   // true (верно)
// @ts-ignore
console.log('2 == 1', 2 == 1) // false (неверно)
console.log('2 == 2', 2 == 2) // true (верно)
// @ts-ignore
console.log('2 != 1', 2 != 1) // true (верно)


// Сравнение строк
// Чтобы определить, что одна строка больше другой, JavaScript использует «алфавитный» или «лексикографический» порядок.

// Другими словами, строки сравниваются посимвольно.

console.log("'Я' > 'А'", 'Я' > 'А') // true
console.log("'Коты' > 'Кода'", 'Коты' > 'Кода') // true
console.log("'Сонный' > 'Сон'", 'Сонный' > 'Сон') // true
// Алгоритм сравнения двух строк довольно прост:

// Сначала сравниваются первые символы строк.
// Если первый символ первой строки больше(меньше), чем первый символ второй, то первая строка больше(меньше) второй.Сравнение завершено.
// Если первые символы равны, то таким же образом сравниваются уже вторые символы строк.
// Сравнение продолжается, пока не закончится одна из строк.
// Если обе строки заканчиваются одновременно, то они равны.Иначе, большей считается более длинная строка.
// В примерах выше сравнение 'Я' > 'А' завершится на первом шаге, тогда как строки 'Коты' и 'Кода' будут сравниваться посимвольно:

// К равна К.
// о равна о.
// т больше, чем д.На этом сравнение заканчивается.Первая строка больше.

// Используется кодировка Unicode, а не настоящий алфавит
// Приведённый выше алгоритм сравнения похож на алгоритм, используемый в словарях и телефонных книгах, но между ними есть и различия.

// Например, в JavaScript имеет значение регистр символов.Заглавная буква "A" не равна строчной "a".Какая же из них больше ? Строчная "a".Почему ? Потому что строчные буквы имеют больший код во внутренней таблице кодирования, которую использует JavaScript(Unicode).Мы ещё поговорим о внутреннем представлении строк и его влиянии в главе Строки.

// Сравнение разных типов
// При сравнении значений разных типов JavaScript приводит каждое из них к числу.

// @ts-ignore
console.log("'2' > 1", '2' > 1); // true, строка '2' становится числом 2
// @ts-ignore
console.log("'01' == 1", '01' == 1); // true, строка '01' становится числом 1
// Логическое значение true становится 1, а false – 0.

Например:

// @ts-ignore
console.log('true == 1', true == 1); // true
// @ts-ignore
console.log('false == 0', false == 0); // true
// Забавное следствие
// Возможна следующая ситуация:

// Два значения равны.
// Одно из них true как логическое значение, другое – false.

let a = 0
console.log('Boolean(a=0)', Boolean(a)) // false

let b = "0"
console.log('Boolean(b="0")', Boolean(b)) // true

// @ts-ignore
console.log('a == b', a == b) // true!
// С точки зрения JavaScript, результат ожидаем.Равенство преобразует значения, используя числовое преобразование, поэтому "0" становится 0. В то время как явное преобразование с помощью Boolean использует другой набор правил.

// !Строгое сравнение
// Использование обычного сравнения == может вызывать проблемы.Например, оно не отличает 0 от false
// !Сравнивает и значения и типы
// Оператор строгого равенства === проверяет равенство без приведения типов

// !Сравнение с null и undefined
// Поведение null и undefined при сравнении с другими значениями — особое:

// При строгом равенстве ===
// Эти значения различны, так как различны их типы.

console.log(null === undefined); // false
// При нестрогом равенстве ==
// Эти значения равны друг другу и не равны никаким другим значениям.Это специальное правило языка.

console.log(null == undefined); // true
// При использовании математических операторов и других операторов сравнения<> <= >=
// Значения null / undefined преобразуются к числам: null становится 0, а undefined – NaN.

// Посмотрим, какие забавные вещи случаются, когда мы применяем эти правила.И, что более важно, как избежать ошибок при их использовании.

// Странный результат сравнения null и 0
// Сравним null с нулём:

// @ts-ignore
console.log(null > 0);  // (1) false
console.log(null == 0); // (2) false
// @ts-ignore
console.log(null >= 0); // (3) true

// С точки зрения математики это странно.Результат последнего сравнения говорит о том, что "null больше или равно нулю", тогда результат одного из сравнений выше должен быть true, но они оба ложны.

// Причина в том, что нестрогое равенство и сравнения > < >= <= работают по - разному.Сравнения преобразуют null в число, рассматривая его как 0. Поэтому выражение(3) null >= 0 истинно, а null > 0 ложно.

// С другой стороны, для нестрогого равенства == значений undefined и null действует особое правило: эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому.Поэтому(2) null == 0 ложно.

// Несравненное значение undefined
// Значение undefined несравнимо с другими значениями:

// @ts-ignore
console.log(undefined > 0); // false (1)
// @ts-ignore
console.log(undefined < 0); // false (2)
console.log(undefined == 0); // false (3)
// Почему же сравнение undefined с нулём всегда ложно ?

// На это есть следующие причины:

// Сравнения(1) и(2) возвращают false, потому что undefined преобразуется в NaN, а NaN – это специальное числовое значение, которое возвращает false при любых сравнениях.
// Нестрогое равенство(3) возвращает false, потому что undefined равно только null, undefined и ничему больше.
// Как избежать проблем
// Зачем мы рассмотрели все эти примеры ? Должны ли мы постоянно помнить обо всех этих особенностях ? Не обязательно.Со временем все они станут вам знакомы, но можно избежать проблем, если следовать надёжным правилам:

// Относитесь очень осторожно к любому сравнению с undefined / null, кроме случаев строгого равенства ===.
// Не используйте сравнения >= > < <= с переменными, которые могут принимать значения null / undefined, разве что вы полностью уверены в том, что делаете.Если переменная может принимать эти значения, то добавьте для них отдельные проверки.
  
// ?Итого
// Операторы сравнения возвращают значения логического типа.
// Строки сравниваются посимвольно в лексикографическом порядке.
// Значения разных типов при сравнении приводятся к числу.Исключением является сравнение с помощью операторов строгого равенства / неравенства.
// Значения null и undefined равны == друг другу и не равны любому другому значению.
// Будьте осторожны при использовании операторов сравнений вроде > и < с переменными, которые могут принимать значения null / undefined.Хорошей идеей будет сделать отдельную проверку на null / undefined.


