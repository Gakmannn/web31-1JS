// import './style.css'
// Комментарий
// alert('Я JS')
console.log('Я JS') // выводит в консоль "Я JS"

console.log(1 +
  2 +
  4)

  // ; ставится только перед квадратными скобками
  ;[1, 2].forEach(console.log)

/*
  Многострочный
  комментарий
*/

// Многострочный
// комментарий

// Объявили переменную m и присвоили ей значение 1 
let m = 1

// объявили несколько переменных через запятую
// let user = 'John', age = 25, message = 'Hello'
// Но лучше определять переменные на новой строке
let user: any = 'John'
let age = 25
let message = 'Hello'
console.log('значение переменной user', user)
user = 'Kate'
console.log('значение переменной user', user)
console.log('значение переменной age', age)
console.log('значение переменной message', message)


let hello = 'Hello world!'

// копируем значение 'Hello world' из переменной hello в переменную message
message = hello

// теперь две переменные содержат одинаковые данные
console.log('значение переменной hello', hello) // Hello world!
console.log('значение переменной message', message) // Hello world!

// Невозможно повторно объявить переменную "hello" с областью видимости "Блок"
// let hello

// При обращении к переменной, которая не была создана при помощи let, движок
// пытается найти её в коде выше, и если не находит, выводится ошибка
// Не удается найти имя "newVar"
// newVar = 10

// !Имена переменных
// В JavaScript есть два ограничения, касающиеся имён переменных:

// !Имя переменной должно содержать только буквы, цифры или символы $ и _.
// !Первый символ не должен быть цифрой.
// Примеры допустимых имён:

let userName
let test123
// Если имя содержит несколько слов, обычно используется верблюжья нотация, то есть, слова следуют одно за другим, где каждое следующее слово начинается с заглавной буквы: myVeryLongName.
// Самое интересное – знак доллара '$' и подчёркивание '_' также можно использовать в названиях.Это обычные символы, как и буквы, без какого - либо особого значения.
// Эти имена являются допустимыми:

let $ = 1; // объявили переменную с именем "$"
let _ = 2; // а теперь переменную с именем "_"

console.log($ + _); // 3

// Создали переменную, имя которой начинается на число
// Идентификатор или ключевое слово не может следовать непосредственно за числовым литералом
// let 1a // не может начинаться с цифры
// let my-name // дефис '-' не разрешён в имени (возпринимается как минус)

// Регистр имеет значение
// Переменные с именами apple и APPLE – это две разные переменные.

// Нелатинские буквы разрешены, но не рекомендуются
// Можно использовать любой язык, включая кириллицу или даже иероглифы, например:

let имя = '...'
let 我 = '...'


// !Зарезервированные имена
// Существует список зарезервированных слов, которые нельзя использовать в качестве имён переменных, потому что они используются самим языком.

// Например: let, class, return и function зарезервированы.

// Приведённый ниже код даёт синтаксическую ошибку:

// let let = 5; // нельзя назвать переменную "let", ошибка!
// let return = 5; // также нельзя назвать переменную "return", ошибка!

// Константы
// Чтобы объявить константную, то есть, неизменяемую переменную, используйте const вместо let:

// Объявления "const" должны быть инициализированы (Должно быть присвоено значение)
// const myBirthday1

const myBirthday = '18.04.1982'
$ = 5
// Не удается задать значение для "myBirthday", так как это константа
// myBirthday = ''

// Константы в верхнем регистре
// Широко распространена практика использования констант в качестве псевдонимов для трудно запоминаемых значений, которые известны до начала исполнения скрипта.

// Названия таких констант пишутся с использованием заглавных букв и подчёркивания.

// Например, сделаем константы для различных цветов в «шестнадцатеричном формате»:

const COLOR_RED = "#F00"
const COLOR_GREEN = "#0F0"
const COLOR_BLUE = "#00F"
const COLOR_ORANGE = "#FF7F00"

// ...когда нам нужно выбрать цвет
let color = COLOR_ORANGE
console.log('color', color) // #FF7F00


// !Типы данных
// Значение в JavaScript всегда относится к данным определённого типа.Например, это может быть строка или число.

// Есть восемь основных типов данных в JavaScript.В этой главе мы рассмотрим их в общем, а в следующих главах поговорим подробнее о каждом.

// Когда мы присвоили какое-то значение переменной, тип этого значения сразу привязался к переменной
// Произошла неявная запись 
// let string:string = 'fsddfg'
let string = 'fsddfg'

// имяПеременной:any - такая запись говорит о том, что мы хотим, чтобы переменная хранила любое значение
let newMessage: any = "hello"
// либо мы можем указать после значения переменной as any
let newMessage2 = "hello" as any
newMessage = 123456
newMessage2 = 465

// !Число
let n = 123
n = 12.345
console.log('1_000_000', 1_000_000)
console.log('10e3', 10e3) // e3 == 10**3
console.log('1e-3', 1e-3) // e3 == 10**-3

console.log('typeof(n)', typeof (n)) // number
// Числовой тип данных(number) представляет как целочисленные значения, так и числа с плавающей точкой.

// Существует множество операций для чисел, например, умножение *, деление /, сложение +, вычитание - и так далее.

// Кроме обычных чисел, существуют так называемые «специальные числовые значения», которые относятся к этому типу данных: Infinity, -Infinity и NaN.

// Infinity представляет собой математическую бесконечность ∞. Это особое значение, которое больше любого числа.

// Мы можем получить его в результате деления на ноль:

console.log(1 / 0); // Infinity
// Или задать его явно:

console.log(Infinity); // Infinity
// NaN означает вычислительную ошибку.Это результат неправильной или неопределённой математической операции, например:

console.log(("не число" as any) / 2); // NaN, такое деление является ошибкой
// Значение NaN «прилипчиво». Любая математическая операция с NaN возвращает NaN:

console.log(NaN + 1); // NaN
console.log(3 * NaN); // NaN
// @ts-ignore
console.log("не число" / 2 - 1) // NaN
// Если где - то в математическом выражении есть NaN, то оно распространяется на весь результат(есть только одно исключение: NaN ** 0 равно 1).

// !символ "n" в конце означает, что это BigInt
const bigInt = 1234567890123456789012345678901234567890n
console.log('typeof(bigInt)', typeof (bigInt)) // bigint

// !Строка
// Строка (string) в JavaScript должна быть заключена в кавычки.

let str = "Привет dfssdf"
console.log('typeof(str)', typeof (str)) // string
// Предпочтительнее использовать одинарные либо косые кавычки для строк
// Для использования переноса строки в обычной строке, мы можем использовать специальный командный символ
// \n

// Обратная косая черта используется в паре с каким либо знаком в 2х вариантах: для экранирования или передачи командного символа

console.log('Строка с экранированной одинарной кавычкой', '\'')
console.log('Строка с экранированной двойной кавычкой', "\"str\"")
console.log('Обычная строка с\nпереносом строки и\tтабуляцией')

let str2 = 'Одинарные \r\n"кавычки" тоже подойдут It\'s'
// Строки с косыми кавычками поддерживаю перенос строки, а так же позволяют встраивать в себя значения переменных
// Их так же называют шаблонными строками
let phrase = `Обратные ${2 + 3}
'кавычки' позволяют 
"встраивать" переменные ${str}`



console.log('str2', str2)
console.log('phrase', phrase)

let name2 = 'Женя'
age = 23

// Такое встраивание хначений в строку называется интерполяцией
console.log(`Привет, меня зовут ${name2}.
Мне ${age} лет.
Через месяц мне будет ${age + 1}`)

// Объявление пустой строки
let emptyString = ''

// !Булевый(логический) тип
// Булевый тип(boolean) может принимать только два значения: true(истина) и false(ложь).

// Такой тип, как правило, используется для хранения значений да / нет: true значит «да, правильно», а false значит «нет, не правильно».

let nameFieldChecked = true // да, поле отмечено
let ageFieldChecked = false // нет, поле не отмечено
// Булевые значения также могут быть результатом сравнений:

console.log('4 > 1', 4 > 1)
// @ts-ignore
console.log('4 == 2', 4 == 2)
console.log('typeof(true)', typeof (true)) // boolean

// !Значение «null»
// Специальное значение null не относится ни к одному из типов, описанных выше.

// Оно формирует отдельный тип, который содержит только значение null:

let newAge = null
// Тип значения null - null, но typeof возвращает object. Это ошибка typeof, ведущая начало с времён создания JavaScript и сохранённая для совместимости
console.log('typeof(null)', typeof (null)) // object
// В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках.

// Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».

// В приведённом выше коде указано, что значение переменной age неизвестно.

// !Значение «undefined»
// Специальное значение undefined также стоит особняком.Оно формирует тип из самого себя так же, как и null.

// Оно означает, что «значение не было присвоено».

// Если переменная объявлена, но ей не присвоено никакого значения, то её значением будет undefined:

let ageN

console.log(ageN) // выведет "undefined"
// Технически мы можем присвоить значение undefined любой переменной:

ageN = 123

// изменяем значение на undefined
ageN = undefined

console.log(ageN) // "undefined"
console.log('typeof(undefined)', typeof (undefined)) // undefined
// …Но так делать не рекомендуется.Обычно null используется для присвоения переменной «пустого» или «неизвестного» значения, а undefined – для проверок, была ли переменная назначена.

// !Объекты и символы
// Тип object(объект) – особенный.
console.log('typeof({})', typeof ({})) // object
// Все остальные типы называются «примитивными», потому что их значениями могут быть только простые значения(будь то строка, или число, или что - то ещё).В объектах же хранят коллекции данных или более сложные структуры.

// Объекты занимают важное место в языке и требуют особого внимания.Мы разберёмся с ними в главе Объекты после того, как узнаем больше о примитивах.

// Тип symbol(символ) используется для создания уникальных идентификаторов в объектах.Мы упоминаем здесь о нём для полноты картины, изучим этот тип после объектов.
console.log('typeof(Symbol("id"))', typeof Symbol('id')) // symbol

// Функция не является отдельным типом данных, но typeof возвращает для неё значение function
console.log('typeof(alert)', typeof alert) // function

// В JavaScript есть 8 основных типов данных.

// Семь из них называют «примитивными» типами данных:
// number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253 - 1).
// bigint для целых чисел произвольной длины.
// string для строк.Строка может содержать ноль или больше символов, нет отдельного символьного типа.
// boolean для true / false.
// null для неизвестных значений – отдельный тип, имеющий одно значение null.
// undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.
// symbol для уникальных идентификаторов.
// И один не является «примитивным» и стоит особняком:
// object для более сложных структур данных.
// Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.

// Имеет две формы: typeof x или typeof (x).
// Возвращает строку с именем типа.Например, "string".
// Для null возвращается "object" – это ошибка в языке, на самом деле это не объект.

// !!!Литералы JavaScript - это фиксированное значение, которое нельзя изменить, вам не нужно указывать какой - либо тип ключевого слова для записи литералов. Литералы часто используются для инициализации переменных в программировании, имена переменных являются строковыми литералами.

let num = 132

// функция alert выводит сообщение на экран, блокируя отображение
// функция prompt запрашивает у пользователя, блокируя отображение
// !Любой пользовательский ввод - это всегда строка!
// !Чтобы преобразовать строку в число, неободимо сделать преобразование
// parseInt - функция, которая достаёт целое число из строки, если эта строка начинается на число
// let input = parseInt(prompt('Введите число','0') as string)

// parseFloat - функция, которая достаёт число c плавающей запятой из строки, если эта строка начинается на число

// 1 Запросите у пользователя число, возведите это число во 2 - ю степень и выведите на экран.
// let input = parseFloat(prompt('Введите число','0') as string)
// alert(`sum ${input-input}
// div ${input+input}`)

// Показывает пользователю текст сообщения, на что пользователь может нажать ОК или отмена
// Если пользователь нажал ОК, возвращает true
// Если пользователь нажал отмена, возвращает false
// confirm('текст сообщения')

// !Преобразование значений примитивов
// ?Строковое преобразование

let value = true
console.log('typeof true', typeof value) // boolean

// функция String(value), преобразует значение к строке

let strValue = String(value) // теперь value это строка "true"
console.log('typeof "true"', typeof strValue) // string
console.log('String(1)', String(1))
console.log('String(null)', String(null))
console.log('String(undefined)', String(undefined))

// ?Численное преобразование

// !Численное преобразование происходит в математических функциях и выражениях.

// Например, когда операция деления / применяется не к числу:

// Операции, которые всегда неявно приводят операнды к числу, получаем число
// TS ругается, когда мы пытаемся делить строки
// @ts-ignore
console.log('"6" / "2"', "6" / "2") // 3, строки преобразуются в числа
// @ts-ignore
console.log('"6" * "2" =', "6" * "2") // 12
// @ts-ignore
console.log('"6" ** "2" =', "6" ** "2") // 36
// @ts-ignore  
console.log('"6" % "2" =', "6" % "2") // 6 на 2 делится целиком, остаток 0
// @ts-ignore  % - остаток от целочисленного деления
console.log('"7" % "2" =', "7" % "2") // 1
// @ts-ignore
console.log('"7.5" % "2" =', "7.5" % "2") // 1
// @ts-ignore
console.log('"6" - "2" =', "6" - "2") // 4


// Сложение строк называется конкатенацией. Эта поерация склеивает две строки в одну
console.log('"6" + "2" =', "6" + "2") // '62'
console.log('"6" + 2 =', "6" + 2) // '62'
console.log('6 + "2" =', 6 + "2") // '62'
// Операции сложения происходят слева на право
console.log('8 + 6 + "2" =', 8 + 6 + "2") // '142'
// Скобки имеют высший приоритет
console.log('"1" + (8 + 6) + "2" =', "1" + (8 + 6) + "2") // '1142'


// Мы можем использовать функцию Number(value), чтобы явно преобразовать value к числу:

str = "123"
console.log(typeof str) // string

num = Number(str) // становится числом 123

console.log(typeof num) // number

console.log('Number("1")', Number("1"))             // 1
console.log('Number("1(one)")', Number("1(one)"))   // NaN
console.log('Number(null)', Number(null))           // 0
console.log('Number(undefined)', Number(undefined)) // NaN

// Правила численного преобразования:

// Значение	Преобразуется в…
// undefined	NaN
// null	0
// true / false	1 / 0
// string	Пробельные символы(пробелы, знаки табуляции \t, знаки новой строки \n и т.п.) по краям обрезаются.
// Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число.
// При ошибке результат NaN.

console.log('Number("   123   ")', Number("   123   ")) // 123
console.log('Number("   \n\t   ")', Number("   \n\t   ")) // 0
console.log('Number("")', Number("")) // 0
console.log('Number("123z")', Number("123z"))      // NaN (ошибка чтения числа на месте символа "z")
console.log('Number(true)', Number(true))        // 1
console.log('Number(false)', Number(false))       // 0

// Короткая запись преобразования к числу
console.log('+true', +true)        // 1
console.log('+"2"', +"2")          // 2

console.log('3 + +"2"', 3 + +"2")  // 5
console.log('3 + Number("2")', 3 + Number("2"))  // 5

// ?Логическое преобразование

// Правило преобразования:

// Значения, которые интуитивно «пустые», вроде 0, пустой строки, null, undefined и NaN, становятся false.
// Все остальные значения становятся true

// !!! Здесь предствлены все значения, которые преобразуются к false
console.log('Здесь предствлены все значения, которые преобразуются к false')
console.log('Boolean(0)', Boolean(0)) // false
console.log('Boolean("")', Boolean("")) // false
console.log('Boolean(null)', Boolean(null)) // false
console.log('Boolean(undefined)', Boolean(undefined)) // false
console.log('Boolean(NaN)', Boolean(NaN)) // false

console.log('Boolean(-10)', Boolean(-10)) // true

console.log('Boolean("Привет!")', Boolean("Привет!")) // true
// Заметим, что строчка с нулём "0" — это true
// Некоторые языки(к примеру, PHP) воспринимают строку "0" как false.Но в JavaScript, если строка не пустая, то она всегда true.
// !!! Строка с пробелом и стока с нулём
console.log('Boolean("0")', Boolean("0")) // true
console.log('Boolean(" ")', Boolean(" ")) // пробел это тоже true (любая непустая строка это true)

// Короткая запись преобразования к булеву
console.log('!!" "', !!" ") // !! - двойное отрицание, краткая запись приведения к булеву

// Оператор ! и операция отрицания
console.log('!true', !true) // false 
console.log('!false', !false) // true
console.log('!0', !0) // true

// Термины: «унарный», «бинарный», «операнд»
// Прежде, чем мы двинемся дальше, давайте разберёмся с терминологией.

// Операнд – то, к чему применяется оператор.Например, в умножении 5 * 2 есть два операнда: левый операнд равен 5, а правый операнд равен 2. Иногда их называют «аргументами» вместо «операндов».

// Унарным называется оператор, который применяется к одному операнду.Например, оператор унарный минус "-" меняет знак числа на противоположный:

let x = 1

x = -x
console.log(x) // -1, применили унарный минус
// Бинарным называется оператор, который применяется к двум операндам.Тот же минус существует и в бинарной форме:

x = 1
let y = 3
console.log(y - x) // 2, бинарный минус вычитает значения
// Формально, в последних примерах мы говорим о двух разных операторах, использующих один символ: оператор отрицания(унарный оператор, который обращает знак) и оператор вычитания(бинарный оператор, который вычитает одно число из другого)

// Взятие остатка %
// Оператор взятия остатка %, несмотря на обозначение, никакого отношения к процентам не имеет.

// Результат a % b – это остаток от целочисленного деления a на b.

console.log(5 % 2) // 1, остаток от деления 5 на 2
console.log(8 % 3) // 2, остаток от деления 8 на 3
console.log(8 % 4) // 0, остаток от деления 8 на 4

// Математически, оператор работает и для нецелых чисел.Например, квадратный корень является возведением в степень 1 / 2:

console.log(4 ** (1 / 2)) // 2 (степень 1/2 эквивалентна взятию квадратного корня)
console.log(8 ** (1 / 3)) // 2 (степень 1/3 эквивалентна взятию кубического корня)

// ?Сокращённая арифметика с присваиванием

n = 2
n += 5 // теперь n = 7 (работает как n = n + 5)
n *= 2 // теперь n = 14 (работает как n = n * 2)
n /= 2 // теперь n = 7 (работает как n = n / 2)
n = 5 // теперь n = 2 (работает как n = n - 5)
n **= 2 // теперь n = 4 (работает как n = n ** 2)
n %= 3 // теперь n = 1 (работает как n = n % 3 )

// Инкремент / декремент
// Одной из наиболее частых числовых операций является увеличение или уменьшение на единицу.

// Для этого существуют даже специальные операторы:

// Инкремент++ увеличивает переменную на 1:

let counter = 2
counter++             // работает как counter = counter + 1, просто запись короче
console.log(counter)  // 3
// Декремент-- уменьшает переменную на 1:

counter = 2
counter--            // работает как counter = counter - 1, просто запись короче
console.log(counter) // 1

// !Инкремент / декремент можно применить только к переменной.Попытка использовать его на значении, типа 5++, приведёт к ошибке.

// Операторы++ и-- могут быть расположены не только после, но и до переменной.

// Когда оператор идёт после переменной — это «постфиксная форма»: counter++.
// «Префиксная форма» — это когда оператор идёт перед переменной: ++counter.
// Обе эти инструкции делают одно и то же: увеличивают counter на 1.

// Есть ли разница между ними ? Да, но увидеть её мы сможем, только если будем использовать значение, которое возвращают++ / --.

// Давайте проясним этот момент.Как мы знаем, все операторы возвращают значение.Операторы инкремента / декремента не исключение.Префиксная форма возвращает новое значение, в то время как постфиксная форма возвращает старое(до увеличения / уменьшения числа).

// Чтобы увидеть разницу, вот небольшой пример:

// Префиксная форма возвращает новое значение
counter = 1
console.log('counter = 1')
console.log('++counter', ++counter)
console.log('counter', counter)

// Постфиксная форма возвращает старое значение
counter = 1
console.log('counter = 1')
console.log('counter++', counter++)
console.log('counter', counter)

// !Если результат оператора не используется, а нужно только увеличить/уменьшить переменную, тогда без разницы, какую форму использовать. Обычно используется именно так

counter++

// let a = +(prompt("Первое число?", '1') as string)
//     a = Number(prompt("Первое число?", '1'))
//     a = parseInt(prompt("Первое число?", '1') as string)
//     a = parseFloat(prompt("Первое число?", '1') as string)

// !Операторы сравнения
// Многие операторы сравнения известны нам из математики.

// В JavaScript они записываются так:

// Больше / меньше: a > b, a < b.
// Больше / меньше или равно: a >= b, a <= b.
// Равно: a == b.Обратите внимание, для сравнения используется двойной знак равенства ==.Один знак равенства a = b означал бы присваивание.
// Не равно.В математике обозначается символом ≠, но в JavaScript записывается как a != b.
// В этом разделе мы больше узнаем про то, какие бывают сравнения, как язык с ними работает и к каким неожиданностям мы должны быть готовы.

// Результат сравнения имеет логический тип
// Все операторы сравнения возвращают значение логического типа:

// true – означает «да», «верно», «истина».
// false – означает «нет», «неверно», «ложь».

console.log('2 > 1', 2 > 1)   // true (верно)
// @ts-ignore
console.log('2 == 1', 2 == 1) // false (неверно)
console.log('2 == 2', 2 == 2) // true (верно)
// @ts-ignore
console.log('2 != 1', 2 != 1) // true (верно)


// Сравнение строк
// Чтобы определить, что одна строка больше другой, JavaScript использует «алфавитный» или «лексикографический» порядок.

// Другими словами, строки сравниваются посимвольно.

console.log("'Я' > 'А'", 'Я' > 'А') // true
console.log("'Коты' > 'Кода'", 'Коты' > 'Кода') // true
console.log("'Сонный' > 'Сон'", 'Сонный' > 'Сон') // true
// Алгоритм сравнения двух строк довольно прост:

// Сначала сравниваются первые символы строк.
// Если первый символ первой строки больше(меньше), чем первый символ второй, то первая строка больше(меньше) второй.Сравнение завершено.
// Если первые символы равны, то таким же образом сравниваются уже вторые символы строк.
// Сравнение продолжается, пока не закончится одна из строк.
// Если обе строки заканчиваются одновременно, то они равны.Иначе, большей считается более длинная строка.
// В примерах выше сравнение 'Я' > 'А' завершится на первом шаге, тогда как строки 'Коты' и 'Кода' будут сравниваться посимвольно:

// К равна К.
// о равна о.
// т больше, чем д.На этом сравнение заканчивается.Первая строка больше.

// Используется кодировка Unicode, а не настоящий алфавит
// Приведённый выше алгоритм сравнения похож на алгоритм, используемый в словарях и телефонных книгах, но между ними есть и различия.

// Например, в JavaScript имеет значение регистр символов.Заглавная буква "A" не равна строчной "a".Какая же из них больше ? Строчная "a".Почему ? Потому что строчные буквы имеют больший код во внутренней таблице кодирования, которую использует JavaScript(Unicode).Мы ещё поговорим о внутреннем представлении строк и его влиянии в главе Строки.

// Сравнение разных типов
// При сравнении значений разных типов JavaScript приводит каждое из них к числу.

// @ts-ignore
console.log("'2' > 1", '2' > 1); // true, строка '2' становится числом 2
// @ts-ignore
console.log("'01' == 1", '01' == 1); // true, строка '01' становится числом 1
// Логическое значение true становится 1, а false – 0.

Например:

// @ts-ignore
console.log('true == 1', true == 1); // true
// @ts-ignore
console.log('false == 0', false == 0); // true
// Забавное следствие
// Возможна следующая ситуация:

// Два значения равны.
// Одно из них true как логическое значение, другое – false.

let a = 0
console.log('Boolean(a=0)', Boolean(a)) // false

let b = "0"
console.log('Boolean(b="0")', Boolean(b)) // true

// @ts-ignore
console.log('a == b', a == b) // true!
// С точки зрения JavaScript, результат ожидаем.Равенство преобразует значения, используя числовое преобразование, поэтому "0" становится 0. В то время как явное преобразование с помощью Boolean использует другой набор правил.

// !Строгое сравнение
// Использование обычного сравнения == может вызывать проблемы.Например, оно не отличает 0 от false
// !Сравнивает и значения и типы
// Оператор строгого равенства === проверяет равенство без приведения типов

// !Сравнение с null и undefined
// Поведение null и undefined при сравнении с другими значениями — особое:

// При строгом равенстве ===
// Эти значения различны, так как различны их типы.

console.log(null === undefined); // false
// При нестрогом равенстве ==
// Эти значения равны друг другу и не равны никаким другим значениям.Это специальное правило языка.

console.log(null == undefined); // true
// При использовании математических операторов и других операторов сравнения<> <= >=
// Значения null / undefined преобразуются к числам: null становится 0, а undefined – NaN.

// Посмотрим, какие забавные вещи случаются, когда мы применяем эти правила.И, что более важно, как избежать ошибок при их использовании.

// Странный результат сравнения null и 0
// Сравним null с нулём:

// @ts-ignore
console.log(null > 0);  // (1) false
console.log(null == 0); // (2) false
// @ts-ignore
console.log(null >= 0); // (3) true

// С точки зрения математики это странно.Результат последнего сравнения говорит о том, что "null больше или равно нулю", тогда результат одного из сравнений выше должен быть true, но они оба ложны.

// Причина в том, что нестрогое равенство и сравнения > < >= <= работают по - разному.Сравнения преобразуют null в число, рассматривая его как 0. Поэтому выражение(3) null >= 0 истинно, а null > 0 ложно.

// С другой стороны, для нестрогого равенства == значений undefined и null действует особое правило: эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому.Поэтому(2) null == 0 ложно.

// Несравненное значение undefined
// Значение undefined несравнимо с другими значениями:

// @ts-ignore
console.log(undefined > 0); // false (1)
// @ts-ignore
console.log(undefined < 0); // false (2)
console.log(undefined == 0); // false (3)
// Почему же сравнение undefined с нулём всегда ложно ?

// На это есть следующие причины:

// Сравнения(1) и(2) возвращают false, потому что undefined преобразуется в NaN, а NaN – это специальное числовое значение, которое возвращает false при любых сравнениях.
// Нестрогое равенство(3) возвращает false, потому что undefined равно только null, undefined и ничему больше.
// Как избежать проблем
// Зачем мы рассмотрели все эти примеры ? Должны ли мы постоянно помнить обо всех этих особенностях ? Не обязательно.Со временем все они станут вам знакомы, но можно избежать проблем, если следовать надёжным правилам:

// Относитесь очень осторожно к любому сравнению с undefined / null, кроме случаев строгого равенства ===.
// Не используйте сравнения >= > < <= с переменными, которые могут принимать значения null / undefined, разве что вы полностью уверены в том, что делаете.Если переменная может принимать эти значения, то добавьте для них отдельные проверки.

// ?Итого
// Операторы сравнения возвращают значения логического типа.
// Строки сравниваются посимвольно в лексикографическом порядке.
// Значения разных типов при сравнении приводятся к числу.Исключением является сравнение с помощью операторов строгого равенства / неравенства.
// Значения null и undefined равны == друг другу и не равны любому другому значению.
// Будьте осторожны при использовании операторов сравнений вроде > и < с переменными, которые могут принимать значения null / undefined.Хорошей идеей будет сделать отдельную проверку на null / undefined.


// !Инструкция «if»
// Инструкция if (...) вычисляет условие в скобках и, если результат true, то выполняет блок кода.
// Преобразование к логическому типу
// ?Инструкция if (…) вычисляет выражение в скобках и преобразует результат к логическому типу.
// !Число 0, пустая строка "", null, undefined и NaN становятся false. Из-за этого их называют «ложными» («falsy») значениями.
// !Остальные значения становятся true, поэтому их называют «правдивыми» («truthy»).

let year = 2014

// Одна проверка, один резултат. Записывается в одну строку
if (year == 2015) console.log('Вы правы!')

// year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '')
// Если в результате проверки должны выполниться какие-то инструкции, используем конструкцию if...else
if (year == 2015) {
  console.log('Да вы знаток!')
} else {
  console.log('А вот и неправильно!') // любое значение, кроме 2015
}
// Если в результате проверки хотим что-то присвоить какой-то переменной, используем конструкцию тернарный оператор
let result = (year == 2015) ? 'Да вы знаток!' : 'А вот и неправильно!'
console.log('result', result)


// Сработать может только одно условие. Код эттого условия выполнится и исполнение программы перейдёт к концу условного оператора
// Обязательная часть кода
if (year < 1015) {
  console.log('Это ОЧЕНЬ рано...')
  // Необязательная часть кода. Может повторяться для разных условий сколько угодно раз
} else if (year < 2015) {
  console.log('Это слишком рано')
} else if (year > 2015) {
  console.log('Это поздновато')
} else if (year > 3015) {
  console.log('Вряд ли')
  // Необязательная часть кода. Может применяться только раз. Сработает, если всё, что было выше не сработало
} else {
  console.log('Верно!')
}

// Сюда попадаем, если выполнилось ходь одно условие или else

// !Условный оператор „?“
// Иногда нам нужно определить переменную в зависимости от условия.

let accessAllowed
// age = +(prompt('Сколько вам лет?', '') as string)

if (age > 18) {
  accessAllowed = true
} else {
  accessAllowed = false
}

console.log(accessAllowed)
// Так называемый «условный» оператор «вопросительный знак» позволяет нам сделать это более коротким и простым способом.
// Оператор представлен знаком вопроса?.Его также называют «тернарный», так как этот оператор, единственный в своём роде, имеет три аргумента.

// let result = условие ? значение1 : значение2;

// Сначала вычисляется условие: если оно истинно, тогда возвращается значение1, в противном случае – значение2.

accessAllowed = (age > 18) ? true : false

// Технически, мы можем опустить круглые скобки вокруг age > 18. Оператор вопросительного знака имеет низкий приоритет, поэтому он выполняется после сравнения >.
// оператор сравнения "age > 18" выполняется первым в любом случае
// (нет необходимости заключать его в скобки)
accessAllowed = age > 18 ? true : false
// Но скобки делают код более простым для восприятия, поэтому мы рекомендуем их использовать.

// ?В примере выше вы можете избежать использования оператора вопросительного знака ?, т.к.сравнение само по себе уже возвращает true / false:

// то же самое
accessAllowed = age > 18


// !Несколько операторов „?“
// Последовательность операторов вопросительного знака ? позволяет вернуть значение, которое зависит от более чем одного условия.

age = 18

message = (age < 3) ? 'Здравствуй, малыш!' :
  (age < 18) ? 'Привет!' :
    (age < 100) ? 'Здравствуйте!' :
      'Какой необычный возраст!'

console.log(message);
// Поначалу может быть сложно понять, что происходит.Но при ближайшем рассмотрении мы видим, что это обычная последовательная проверка:

// Первый знак вопроса проверяет age < 3.
// Если верно – возвращает 'Здравствуй, малыш!'.В противном случае, проверяет выражение после двоеточия „:“, вычисляет age < 18.
// Если это верно – возвращает 'Привет!'.В противном случае, проверяет выражение после следующего двоеточия „:“, вычисляет age < 100.
// Если это верно – возвращает 'Здравствуйте!'.В противном случае, возвращает выражение после последнего двоеточия – 'Какой необычный возраст!'.
// Вот как это выглядит при использовании if..else:

if (age < 3) {
  message = 'Здравствуй, малыш!';
} else if (age < 18) {
  message = 'Привет!';
} else if (age < 100) {
  message = 'Здравствуйте!';
} else {
  message = 'Какой необычный возраст!';
}

// ?При чтении глаза сканируют код по вертикали.Блоки кода, занимающие несколько строк, воспринимаются гораздо легче, чем длинный горизонтальный набор инструкций.
// !Смысл оператора «вопросительный знак» ? – вернуть то или иное значение, в зависимости от условия.Пожалуйста, используйте его именно для этого.Когда вам нужно выполнить разные ветви кода – используйте if.

// !Конструкция "switch"
// Конструкция switch заменяет собой сразу несколько if.

// Она представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами.

// Синтаксис
// Конструкция switch имеет один или более блок case и необязательный блок default.

// Выглядит она так:

// switch (x) {
//   case 'value1':  // if (x === 'value1')
//     ...
//     [break]

//   case 'value2':  // if (x === 'value2')
//     ...
//     [break]

//   default:
//     ...
//     [break]
// }
// Переменная x проверяется на строгое равенство первому значению value1, затем второму value2 и так далее.
// Если соответствие установлено – switch начинает выполняться от соответствующей директивы case и далее, до ближайшего break (или до конца switch).
// Если ни один case не совпал – выполняется(если есть) вариант default.
// a = 2+2
a = 1

// break - обязательная инструкция, если мы не хотим, чтобы исполнилось всё подряд

switch (a) {
  case 1: // (a===1)
    console.log('Маловато 1')
    break
  case 2: // (a===2)
    console.log('Маловато 2')
    break
  case 3: // (a===3)
    console.log('Маловато 3')
    break
  case 4: // (a===4)
    console.log('В точку!')
    break
  case 5: // (a===5)
    console.log('Перебор')
    break
  default: // Если ничего не совпало
    console.log("Нет таких значений")
}

// Здесь оператор switch последовательно сравнит a со всеми вариантами из case.

// Сначала 3, затем – так как нет совпадения – 4. Совпадение найдено, будет выполнен этот вариант, со строки alert('В точку!') и далее, до ближайшего break, который прервёт выполнение.

// Если break нет, то выполнение пойдёт ниже по следующим case, при этом остальные проверки игнорируются.

// || (ИЛИ)
// Оператор «ИЛИ» выглядит как двойной символ вертикальной черты:

// result = a || b;
// Традиционно в программировании ИЛИ предназначено только для манипулирования булевыми значениями: в случае, если какой - либо из аргументов true, он вернёт true, в противоположной ситуации возвращается false.

// В JavaScript, как мы увидим далее, этот оператор работает несколько иным образом.Но давайте сперва посмотрим, что происходит с булевыми значениями.

// Существует всего четыре возможные логические комбинации:

console.log('true || true', true || true);   // true
console.log('false || true', false || true);  // true
console.log('true || false', false || true);  // true
console.log('false || false', false || true); // false

// Как мы можем наблюдать, результат операций всегда равен true, за исключением случая, когда оба аргумента false.

// Если значение не логического типа, то оно к нему приводится в целях вычислений.

//   Например, число 1 будет воспринято как true, а 0 – как false:

if (1 || 0) { // работает как if( true || false )
  console.log('truthy!');
}
// Обычно оператор || используется в if для проверки истинности любого из заданных условий.

// К примеру:

let hour = 9;

if (hour < 10 || hour > 18) {
  console.log('Офис закрыт.');
}
// Можно передать и больше условий:

hour = 12;
let isWeekend = true;

if (hour < 10 || hour > 18 || isWeekend) {
  console.log('Офис закрыт.'); // это выходной
}

// !ИЛИ "||" находит первое истинное значение
// Описанная выше логика соответствует традиционной.Теперь давайте поработаем с «дополнительными» возможностями JavaScript.

// Расширенный алгоритм работает следующим образом.

// При выполнении ИЛИ || с несколькими значениями:

// result = value1 || value2 || value3;
// Оператор || выполняет следующие действия:

// ?1 Вычисляет операнды слева направо.
// ?2 Каждый операнд конвертирует в логическое значение.Если результат true, останавливается и возвращает исходное значение этого операнда.
// ?3 Если все операнды являются ложными(false), возвращает последний из них.
// ?4 Значение возвращается в исходном виде, без преобразования.

// Другими словами, цепочка ИЛИ || возвращает первое истинное значение или последнее, если такое значение не найдено.

console.log('1 || 0', 1 || 0) // 1
console.log("true || 'no matter what'", true || 'no matter what'); // true

console.log('null || 1', null || 1); // 1 (первое истинное значение)
console.log('null || 0 || 1', null || 0 || 1); // 1 (первое истинное значение)
console.log('undefined || null || 0', undefined || null || 0); // 0 (поскольку все ложно, возвращается последнее значение)
// Это делает возможным более интересное применение оператора по сравнению с «чистым, традиционным, только булевым ИЛИ».

// && (И)
// Оператор И пишется как два амперсанда &&:

// result = a && b;
// В традиционном программировании И возвращает true, если оба аргумента истинны, а иначе – false:

console.log('true && true', true && true);   // true
console.log('false && true', false && true);  // false
console.log('true && false', true && false);  // false
console.log('false && false', false && false); // false


hour = 12;
let minute = 30;

if (hour == 12 && minute == 30) {
  console.log('The time is 12:30');
}
// Как и в случае с ИЛИ, любое значение допускается в качестве операнда И:

if (1 && 0) { // вычисляется как true && false
  alert("не сработает, так как результат ложный");
}

// !И «&&» находит первое ложное значение
// При нескольких подряд операторах И:

// result = value1 && value2 && value3;
// Оператор && выполняет следующие действия:

// ?1 Вычисляет операнды слева направо.
// ?2 Каждый операнд преобразует в логическое значение.Если результат false, останавливается и возвращает исходное значение этого операнда.
// ?3 Если все операнды были истинными, возвращается последний.
// ?4 Другими словами, И возвращает первое ложное значение.Или последнее, если ничего не найдено.

// Вышеуказанные правила схожи с поведением ИЛИ.Разница в том, что И возвращает первое ложное значение, а ИЛИ –  первое истинное.

// Если первый операнд истинный,
// И возвращает второй:
console.log('1 && 0', 1 && 0); // 0
console.log('1 && 5', 1 && 5); // 5

// Если первый операнд ложный,
// И возвращает его. Второй операнд игнорируется
console.log('null && 5', null && 5); // null
console.log('0 && "no matter what"', 0 && "no matter what"); // 0
// Можно передать несколько значений подряд.В таком случае возвратится первое «ложное» значение, на котором остановились вычисления.

console.log('1 && 2 && null && 3', 1 && 2 && null && 3); // null
// Когда все значения верны, возвращается последнее

console.log('1 && 2 && 3', 1 && 2 && 3); // 3
// Приоритет оператора && больше, чем у ||
// Приоритет оператора И && больше, чем ИЛИ ||, так что он выполняется раньше.

// Таким образом, код a && b || c && d по существу такой же, как если бы выражения && были в круглых скобках: (a && b) || (c && d).

// !(НЕ)
// Оператор НЕ представлен восклицательным знаком!.

// Синтаксис довольно прост:

// result = !value;
// Оператор принимает один аргумент и выполняет следующие действия:

// Сначала приводит аргумент к логическому типу true / false.
// Затем возвращает противоположное значение.

console.log('!true', !true); // false
console.log('!0', !0); // true
// В частности, двойное НЕ!! используют для преобразования значений к логическому типу:

console.log('!!"non-empty string"', !!"non-empty string"); // true
console.log('!!null', !!null); // false
// То есть первое НЕ преобразует значение в логическое значение и возвращает обратное, а второе НЕ снова инвертирует его.В конце мы имеем простое преобразование значения в логическое.

// Есть немного более подробный способ сделать то же самое – встроенная функция Boolean:

console.log('Boolean("non-empty string")', Boolean("non-empty string")); // true
console.log('Boolean(null)', Boolean(null)); // false
// Приоритет НЕ! является наивысшим из всех логических операторов, поэтому он всегда выполняется первым, перед && или ||.

// !Оператор нулевого слияния(??)
// Новая возможность
// Эта возможность была добавлена в язык недавно.В старых браузерах может понадобиться полифил.
// Оператор нулевого слияния представляет собой два вопросительных знака ??.

// Так как он обрабатывает null и undefined одинаковым образом, то для этой статьи мы введём специальный термин.Для краткости будем говорить, что значение «определено», если оно не равняется ни null, ни undefined.

// ?Результат выражения a ?? b будет следующим:
// ?если a определено, то a,
// ?если a не определено, то b.

// Иначе говоря, оператор ?? возвращает первый аргумент, если он не null / undefined, иначе второй.

// Оператор нулевого слияния не является чем - то принципиально новым.Это всего лишь удобный синтаксис, как из двух значений получить одно, которое «определено».

// Вот как можно переписать выражение result = a ?? b, используя уже знакомые нам операторы:

// result = (a !== null && a !== undefined) ? a : b;
// Теперь должно быть абсолютно ясно, что делает ??.Давайте посмотрим, где это может быть полезно.

// Как правило, оператор ?? нужен для того, чтобы задать значение по умолчанию для потенциально неопределённой переменной.

// Например, здесь мы отобразим user, если её значение не null / undefined, в противном случае Аноним:

user;

console.log(user ?? "Аноним"); // Аноним (user не существует)
// А вот пример, когда user присвоено значение:

user = "Иван";

console.log(user ?? "Аноним"); // Иван (user существует)
// Кроме этого, можно записать последовательность из операторов ??, чтобы получить первое значение из списка, которое не является null / undefined.

// Допустим, у нас есть данные пользователя в переменных firstName, lastName или nickName.Все они могут не существовать, если пользователь решил не вводить соответствующие значение.

// Мы хотели бы отобразить имя пользователя, используя одну из этих переменных, или показать «Аноним», если все они null / undefined.

// Для этого воспользуемся оператором ??:

let firstName = null;
let lastName = null;
let nickName = "Суперкодер";

// показывает первое значение, которое определено:
console.log(firstName ?? lastName ?? nickName ?? "Аноним"); // Суперкодер

// ! Единственное отличие от || в том, что ?? считает ложью только null и undefined

// !Приоритет оператора ?? такой же, как и у ||.Они оба равны 3 в таблице на MDN.

// Использование ?? вместе с && или ||
// По соображениям безопасности JavaScript запрещает использование оператора ?? вместе с && и ||, если приоритет явно не указан при помощи круглых скобок.

// Выполнение следующего кода приведёт к синтаксической ошибке:

// let x = 1 && 2 ?? 3; // Синтаксическая ошибка

// Это, безусловно, спорное ограничение было добавлено в спецификацию языка с целью избежать программные ошибки, когда люди начнут переходить с || на ??.

// Используйте скобки, чтобы обойти это ограничение:

x = (1 && 2) ?? 3; // Работает без ошибок

// Итого
// Оператор нулевого слияния ?? — это быстрый способ выбрать первое «определённое» значение из списка.

// Используется для присвоения переменным значений по умолчанию:

// будет height=100, если переменная height равна null или undefined
// height = height ?? 100;
// Оператор ?? имеет очень низкий приоритет, лишь немного выше, чем у ? и =, поэтому при использовании его в выражении, скорее всего, потребуются скобки.

// Запрещено использовать вместе с || или && без явно указанного приоритета, то есть без скобок.


// !Методы примитивов
// JavaScript позволяет нам работать с примитивными типами данных – строками, числами и т.д., как будто они являются объектами.У них есть и методы.Мы изучим их позже, а сначала разберём, как это всё работает, потому что, конечно, примитивы – не объекты.

// Давайте взглянем на ключевые различия между примитивами и объектами.

// Примитив

// Это – значение «примитивного» типа.
// ?Есть 7 примитивных типов: string, number, boolean, symbol, null, undefined и bigint.

// Объект

// Может хранить множество значений как свойства.
// Объявляется при помощи фигурных скобок { }, например: { name: "Рома", age: 30 }. В JavaScript есть и другие виды объектов: например, функции тоже являются объектами.

// Примитив как объект
// Вот парадокс, с которым столкнулся создатель JavaScript:

// !Есть много всего, что хотелось бы сделать с примитивами, такими как строка или число.Было бы замечательно, если бы мы могли обращаться к ним при помощи методов.
// !Примитивы должны быть лёгкими и быстрыми насколько это возможно.
// Выбранное решение, хотя выглядит оно немного неуклюже:

// ?Примитивы остаются примитивами.Одно значение, как и хотелось.
// ?Язык позволяет осуществлять доступ к методам и свойствам строк, чисел, булевых значений и символов.
// ?Чтобы это работало, при таком доступе создаётся специальный «объект - обёртка», который предоставляет нужную функциональность, а после удаляется.
// !Каждый примитив имеет свой собственный «объект - обёртку», которые называются: String, Number, Boolean, Symbol и BigInt.Таким образом, они имеют разный набор методов.

// К примеру, существует метод str.toUpperCase(), который возвращает строку в верхнем регистре.

// Вот, как он работает:

console.log('"Привет".toUpperCase()', "Привет".toUpperCase()) // ПРИВЕТ

// Очень просто, не правда ли ? Вот, что на самом деле происходит в str.toUpperCase():

// Строка str – примитив.В момент обращения к его свойству, создаётся специальный объект, который знает значение строки и имеет такие полезные методы, как toUpperCase().
// Этот метод запускается и возвращает новую строку(показывается в alert).
// !!!Специальный объект удаляется, оставляя только примитив str.
// ?Получается, что примитивы могут предоставлять методы, и в то же время оставаться «лёгкими».

// Движок JavaScript сильно оптимизирует этот процесс.Он даже может пропустить создание специального объекта.Однако, он всё же должен придерживаться спецификаций и работать так, как будто он его создаёт.

// Число имеет собственный набор методов.Например, toFixed(n) округляет число до n знаков после запятой.

console.log('1.24566.toFixed(2)', 1.24566.toFixed(2)) // 1.23

// !ЧИСЛА В JS

// Чтобы писать числа с большим количеством нулей:

// Используйте краткую форму записи чисел – "e", с указанным количеством нулей.Например: 123e6 это 123 с 6 - ю нулями 123000000.
// Отрицательное число после "e" приводит к делению числа на 1 с указанным количеством нулей.Например: 123e-6 это 0.000123(123 миллионных).
// ? Так же для записи числа можно использовать нижнее подчеркивание 100_000
// ? такое число везде будет вести себя как 100000

// Для других систем счисления:
// Можно записывать числа сразу в шестнадцатеричной(0x), восьмеричной(0o) и бинарной(0b) системах счисления
// parseInt(str, base) преобразует строку в целое число в соответствии с указанной системой счисления: 2 ≤ base ≤ 36.
// num.toString(base) представляет число в строковом виде в указанной системе счисления base.

// !Для проверки на NaN и Infinity:
// !isNaN(value) преобразует аргумент в число и проверяет, является ли оно NaN
// Number.isNaN(value) проверяет, является ли аргумент числом, и если да, то проверяет, является ли оно NaN
// !isFinite(value) преобразует аргумент в число и проверяет, что оно не является NaN / Infinity / -Infinity
// Number.isFinite(value) проверяет, является ли аргумент числом, и если да, то проверяет, что оно не является NaN / Infinity / -Infinity

// Для преобразования значений типа 12pt и 100px в число:
// !Используйте parseInt / parseFloat для «мягкого» преобразования строки в число, данные функции по порядку считывают число из строки до тех пор пока не возникнет ошибка.

// Для дробей:
// !Используйте округления Math.floor, Math.ceil, Math.trunc, Math.round или num.toFixed(precision).
// !!!!Помните, что при работе с дробями происходит потеря точности.

console.log('0.1 + 0.2 == 0.3', 0.1 + 0.2 == 0.3) // false
console.log('0.1 + 0.2', 0.1 + 0.2) // 0.30000000000000004

// наиболее надёжный способ обойти эту проблему,- это округлить результат используя метод toFixed(n):

console.log('+(0.1 + 0.2).toFixed(2)', +(0.1 + 0.2).toFixed(2)) // 0.30

// Ещё больше математических функций:
// Документация по объекту Math.Библиотека маленькая, но содержит всё самое важное.

function randomInteger(min: number, max: number) {
  return Math.floor(Math.random() * (max - min + 1) + min)
}

randomInteger(0, 5)


// Итого
// Есть три типа кавычек.Строки, использующие обратные кавычки, могут занимать более одной строки в коде и включать выражения ${… }.
// Строки в JavaScript кодируются в UTF - 16.
// Есть специальные символы, такие как разрыв строки \n.
// Для получения символа используйте[] или метод at.
// Для получения подстроки используйте slice или substring.
// Для того, чтобы перевести строку в нижний или верхний регистр, используйте toLowerCase / toUpperCase.
// Для поиска подстроки используйте indexOf или includes / startsWith / endsWith, когда надо только проверить, есть ли вхождение.
// Чтобы сравнить строки с учётом правил языка, используйте localeCompare.
// Строки также имеют ещё кое - какие полезные методы:

// str.trim() — убирает пробелы в начале и конце строки.
// str.repeat(n) — повторяет строку n раз.
// …и другие, которые вы можете найти в справочнике.
// Для строк предусмотрены методы для поиска и замены с использованием регулярных выражений.Но это отдельная большая тема, поэтому ей посвящена отдельная глава учебника Регулярные выражения.

// Также, на данный момент важно знать, что строки основаны на кодировке Юникод, и поэтому иногда могут возникать проблемы со сравнениями.Подробнее о Юникоде в главе Юникод, внутреннее устройство строк.

// ******  Циклы ******

// ?while - цикл с предусловием; Сначала проверяем условие, потом идём в тело цикла
// while (условие) { Тело цикла выполняется пока условие истинно, иначе управление переходит на следующую строку после цикла (цикл заканчивается)
//   Тело цикла
// }

let i = 1
let n1 = 5
console.log('Цикл while')
while (i <= n1) {
  console.log(i)
  i++
}

// 1. инициация итератора
// 2. проверка условия
// После проверки условия, если оно истинно, выполняется тело цикла. Если ложно,- выход
// 3. После каждого выполнения тела цикла делаем шаг итератора
// 4(2). проверка условия

// ?for (инициация итератора; условие; шаг итератора) {
//   Тело цикла
// }

// Выполнить начало
// → (Если условие == true → Выполнить тело, Выполнить шаг)
// → (Если условие == true → Выполнить тело, Выполнить шаг)
// → (Если условие == true → Выполнить тело, Выполнить шаг)
// → ...

console.log('Цикл for')
for (let i = 1; i <= n1; i++) {
  console.log(i)
}

// Бесконечный цикл с условием выхода
i = 0
while (true) {
  if (i > 500) break
  // if(i%100==0) continue
  i += 50
  if (i % 100 == 0) continue
  console.log(i)
}

// ?do while - цикл с постусловием; Сначала выполняем тело цикла, потом проверяем условие
// do {
//   Тело цикла
// } while (Условие) Тело цикла выполняется пока условие истинно, иначе управление переходит на следующую строку после цикла (цикл заканчивается)

// let number1
// do {
//   // @ts-ignore
//   number1 = +prompt('Введи число больше 0')
// } while (!number1 || number1<=0)

// alert(`количество 0 = ${n1}
// количество положительных 2
// `)

// Вариант с меткой
// outer: for (let i = 0; i < 3; i++) {
//   for (let j = 0; j < 3; j++) {
//     let input = prompt(`Значение на координатах (${i},${j})`, '');
//     // если пустая строка или Отмена, то выйти из обоих циклов
//     if (!input) break outer; // (*)
//     // сделать что-нибудь со значениями...
//   }
// }

// Директива continue также может быть использована с меткой.В этом случае управление перейдёт на следующую итерацию цикла с меткой

// Вариант с флагом
// let stopOuter = false // (Флаг)
// for (let i = 0; i < 3; i++) {
//   if (stopOuter) break
//   for (let j = 0; j < 3; j++) {
//     let input = prompt(`Значение на координатах (${i},${j})`, '');
//     // если пустая строка или Отмена, то выйти из обоих циклов
//     if (!input) {
//       stopOuter = true
//       break
//     } // (*)
//     // сделать что-нибудь со значениями...
//   }
// }

// Чётные без %
// for (let i = 2; i < 11; i += 2) {
//   alert(i)
// }

// Вывести простые числа
// Натуральное число, большее 1, называется простым, если оно ни на что не делится, кроме себя и 1.
// Другими словами, n > 1 – простое, если при его делении на любое число кроме 1 и n есть остаток.
// Например, 5 это простое число, оно не может быть разделено без остатка на 2, 3 и 4.
// Напишите код, который выводит все простые числа из интервала от 2 до n.
// Для n = 10 результат должен быть 2, 3, 5, 7.
// P.S.Код также должен легко модифицироваться для любых других интервалов.

// const maxNumber = +(prompt('До какого числа искать простые') as string)
// console.log(`Простые числа до ${maxNumber}`)
// for (let i=2; i<maxNumber;i++) {
//   let isSimple = true
//   for (let j=2; j<i; j++) {
//     if (i%j==0) {
//       isSimple=false
//       break
//     }
//   }
//   if (isSimple) console.log(i)
// }

// console.log(`second`)
// outer:
// for (let i = 2; i < maxNumber; i++) {
//   for (let j = 2; j < i; j++) {
//     if (!(i % j)) continue outer
//   }
//   console.log(i)
// }


// !Цикл выполнятеся, пока условие истинно
// !Условие всегда автоматически преобразуется к булеву

// ? while(условие) {тело цикла}
// ? do {тело цикла} while(условие)
// ? for (начало, условие, шаг) {тело цикла}

while (false) {
  console.log('никогда не выполнится')
}
while (true) {
  console.log('выполнится только раз, т.к. дальше break')
  break
}

do {
  console.log('выполнится только раз, т.к. условие ложно')
} while (false)

console.log('do...while один раз исполнит тело цикла, даже если условите ложно')
i = 5
do {
  console.log(i)
  i++
} while (i < 4)

console.log('while никогда не исполнит тело цикла, если условите ложно')
i = 5
while (i < 3) {
  console.log(i)
  i++
}

for (let i = 0; i < 10; i += 2) {
  console.log(i)
}

for (let i = 0; i < 3; i++) {
  console.log('i', i)
  for (let j = 0; j < 3; j++) {
    console.log('   j', j)
  }
}

console.log('break')

for (let i = 0; i < 4; i++) {
  if (i == 2) break
  console.log('i', i)
}

console.log('continue')

for (let i = 0; i < 6; i++) {
  if (!(i % 2)) continue
  console.log('i', i)
}

// Вывести простые числа
// Натуральное число, большее 1, называется простым, если оно ни на что не делится, кроме себя и 1.
// Другими словами, n > 1 – простое, если при его делении на любое число кроме 1 и n есть остаток.
// Например, 5 это простое число, оно не может быть разделено без остатка на 2, 3 и 4.
// Напишите код, который выводит все простые числа из интервала от 2 до n.
// Для n = 10 результат должен быть 2, 3, 5, 7.
// P.S.Код также должен легко модифицироваться для любых других интервалов.

console.log('find simple')
n = 10
for (let i = 2; i <= n; i++) {
  // Предполагаем, что число простое
  let isSimple = true
  for (let j = 2; j < i; j++) {
    // Проверям, что число простое
    if (i % j == 0) {
      // Выяснили, что число не простое
      isSimple = false
      break
    }
  }
  // Если число простое, то выводим его
  if (isSimple) console.log(i)
}


console.log('find simple без флага')
n = 10
number: for (let i = 2; i <= n; i++) {
  for (let j = 2; j < i; j++) {
    console.log('i', i, 'j', j)
    // Проверям, что число простое
    if (i % j == 0) {
      // number - имя метки, которое мы придумали
      continue number
    }
  }
  console.log(i)
}

for (let i = 0; i < 'word'.length; i++) {
  console.log(i, 'word'[i])
}

for (let letter of 'word') {
  console.log(letter)
}


// let answer = true
// while (answer) {
//   let intNumb1 = parseFloat(prompt('Введите число/цифру, которое хотите вычислить', '12') as string)
//   let intSign = prompt('Введите знак, который будет вычислять', '+ - * /')
//   let intNumb2 = parseFloat(prompt('Введите число/цыфру, которое хотите вычислить', '12') as string)
//   let res = 0
//   switch (intSign) {
//     case '-':
//       res = intNumb1 - intNumb2
//       break
//     case '+':
//       res = intNumb1 + intNumb2
//       break
//     case '*':
//       res = intNumb1 * intNumb2
//       break
//     case '/':
//       res = intNumb1 / intNumb2
//       break
//   }
//   answer = confirm(`Результат ${res}. Посчитать что-нибудь ещё?`)
// }

// Запросить у пользователя число и на сколько цифр его
// сдвинуть.Сдвинуть цифры числа и вывести результат(если
// число 123456 сдвинуть на 2 цифры, то получится 345612).

let numStr = '123456'
let shift = 3

let newNumStr = ''
for (let i = shift; i < numStr.length; i++) {
  newNumStr += numStr[i]
  console.log(i, numStr[i], newNumStr)
}
for (let i = 0; i < shift; i++) {
  newNumStr += numStr[i]
  console.log(i, numStr[i], newNumStr)
}
console.log(+newNumStr)

// Запросить 2 числа и найти только наибольший общий делитель.

// let intNumb1 = Math.abs(parseFloat(prompt('Введите первое число, для нахождения общего делителя', '18') as string))
// let intNumb2 = Math.abs(parseFloat(prompt('Введите второе число, для нахождения общего делителя', '99') as string))

// // Меньее на большее ровно поделиться не может
// // Найдём, какое из чисел меньше

// let min = intNumb1 > intNumb2 ? intNumb2 : intNumb1

// if (intNumb1 > intNumb2) {
//   min = intNumb2
// } else {
//   min = intNumb1
// }

// // Нашли минимальное. Теперь посмотрим, на какие числа до минимального делятся оба без остатка
// // Все общие делители
// console.log('Все общие делители')
// for (let i = 1; i <= min; i++) {
//   if (intNumb1%i==0 && intNumb2%i==0) {
//     console.log(i)
//   }
// }
// console.log('Наибольший общий делитель')
// for (let i = min; i > 0; i--) {
//   if (intNumb1%i==0 && intNumb2%i==0) {
//     console.log(i)
//     break
//   }
// }

// let day = true;
// let nextDay = prompt('Напишите сегодняшний день, чтобы увидеть следующий', 'Пятница') as string;
// while (day) {

//   switch (nextDay) {
//     case 'Понедельник':
//       nextDay = 'Вторник'
//       break
//     case 'Вторник':
//       nextDay = 'Среда'
//       break
//     case 'Среда':
//       nextDay = 'Четверг'
//       break
//     case 'Четверг':
//       nextDay = 'Пятница'
//       break
//     case 'Пятница':
//       nextDay = 'Суббота'
//       break
//     case 'Суббота':
//       nextDay = 'Воскресенье'
//       break
//     case 'Воскресенье':
//       nextDay = 'Понедельник'
//       break
//     default:
//       nextDay = 'Понедельник'
// }

//   day = confirm(`Cледующий день ${nextDay}, хотите узнать следующий день?`);
// }


// !Функции

// function имя(параметры) {
//   ...тело...
// }

// Функция, объявленная церез ключевое слово function как бы всплывает в самый верх кода. Поэтому её можно вызвать в любом месте
showMessage1(1520) // Вызов функции

function showMessage1(stringNumber: number) {
  console.log('Всем привет из функции! Функция вызвана из строки', stringNumber)
  // функции имеют доступ к глобальным переменным
  console.log('global i', i)
}

showMessage1(1526) // Вызов функции
console.log(showMessage1) // выводится тело функции

// ! Функции всегда что-то возвращают. Если нет явного возврата значения, функция вернёт undefined
console.log(showMessage1(1530)) // undefined


// ! Область видимости

// ? Глобальная область видимости - это просто код, который мы писали везде до этого (кроме кода в фигурных скобках,-тело цикла, тело if/else, тело функции)
// Переменные, объявленные в глобальной области видимости дорступны везде
// Объявление переменной - это ключевые слова let, const, function

// ? Локальная область видимости - это код, внутри любых фигурных скобок
// Переменные, объявленные в локальной области видимости доступны в рамках фигурных скобок, в которых они объявлены, и во всех нижестоящих локальных уровнях
console.log('global i', i)
// здесь j объявляется в локальной области видимости цикла for
for (let j = 0; j < 2; j++) {
  console.log('j', j) // 0,1
  if (j == 0) {
    console.log('j==0', j) // 0,1
    const z = 0
    console.log('z', z)
    let i = 0
    i++
    console.log('local i', i)
  }
  //console.log('z', z) //z is not defined
}
console.log('global i', i)

// перепишем for в while
// Обернул в if, который всегда сработает, чтобы создать локальную область видимости
if (true) {
  let j = 0
  while (j < 2) {
    console.log('j', j) // 0,1
    j++
  }
}

// j не существует в глобальной области видимости. Не объявлена выше по коду
// console.log('j', j) //j is not defined

let j = 10 // переменная j объявлена и существует
console.log('j', j)


// !Параметры
// ?Мы можем передать внутрь функции любую информацию, используя параметры.
// В нижеприведённом примере функции передаются два параметра: from и text.

function showMessage(from: any, text = 'Многозначительно молчит...') { // параметры: from, text
  from = '*' + from + '*'; // немного украсим "from"
  console.log('local from', from);
  // return
  // console.log(from + ': ' + text);
}

showMessage('Аня', 'Привет!'); // *Аня*: Привет! (*)
showMessage('Аня', "Как дела?"); // *Аня*: Как дела? (**)
// Когда функция вызывается в строках(*) и(**), переданные значения копируются в локальные переменные from и text.Затем они используются в теле функции.

// Вот ещё один пример: у нас есть переменная from, и мы передаём её функции.Обратите внимание: функция изменяет значение from, но это изменение не видно снаружи.Функция всегда получает только копию значения:


let from = "Ваня";

showMessage(from, "Привет"); // *Ваня*: Привет
showMessage(from)

// значение "from" осталось прежним, функция изменила значение локальной переменной
console.log('global from', from) // Ваня

// Значение, передаваемое в качестве параметра функции, также называется аргументом.

// Параметр – это переменная, указанная в круглых скобках в объявлении функции.
// Аргумент – это значение, которое передаётся функции при её вызове.
// Мы объявляем функции со списком параметров, затем вызываем их, передавая аргументы.

// Рассматривая приведённый выше пример, мы могли бы сказать: "функция showMessage объявляется с двумя параметрами, затем вызывается с двумя аргументами: from и "Привет"".

function checkAge1(age: number) {
  if (age >= 18) {
    return true;
  } else {
    return confirm('А родители разрешили?');
  }
}
// Более короткий вариант записи 1
function checkAge2(age: number) {
  if (age >= 18) {
    return true;
  }
  return confirm('А родители разрешили?');
}
// Более короткий вариант записи 2
function checkAge3(age: number) {
  return (age >= 18) ? true : confirm('А родители разрешили?')
}

// Написать функцию, которая принимает 2 числа и знак (+ - * /), считает пример и возвращает результат.
function calc(n1 = 5, n2 = 8, sign = '*') {
  switch (sign) {
    case '-':
      return n1 - n2
    case '+':
      return n1 + n2
    case '*':
      return n1 * n2
    case '/':
      return n1 / n2
  }
}

console.log("calc()", calc())
console.log("calc(2,6,'-')", calc(2, 6, '-'))

// Написать функцию, которая принимает от 1 до 5 чисел и возвращает их сумму.
function getSum(n1: number, n2 = 0, n3 = 0, n4 = 0, n5 = 0) {
  return n1 + n2 + n3 + n4 + n5
}
getSum(1, 2, 5)

// TS-style Функция, которая может принять неограниченное количество переменных
function getNSum(n1: number, ...args: any) {
  let sum = n1
  for (let i = 0; i < args.length; i++) {
    sum += args[i]
  }
  return sum
}

console.log(getNSum(1, 5, 8, 9, 4, 7, 65, 4, 5, 8, 46, 698, 46, 65))

console.log(getNSum2(1))

// JS-style Функция, которая может принять неограниченное количество переменных
function getNSum2(n1: number, ...args: any) {
  console.log(arguments) // массив всех значений, которые пришли в функцию
  console.log(args)      // args - общепринятое именование для дополнительных параметров функции
  // тоже является массивом, но в него попадут только те аргументы, которые переданы сверх именованных

  let sum = 0
  for (let i = 0; i < arguments.length; i++) {
    sum += arguments[i]
  }
  return sum
}

console.log(getNSum2(1, 0, 2, 6, 5))

function pow(x: number, n: number) {
  console.log(n)
  return (n == 1) ? x : (x * pow(x, n - 1));
}

function factorial(n: number): number {
  if (n == 1) return n
  return n * factorial(n - 1)
  return 5 * 4 * 3 * 2 * 1
  return 5 * stack * 1
  return 5 * stack * 2 * 1
  return 5 * stack * 3 * 2
  return 5 * 4 * 6
}

console.log(factorial(5))

function strSum(s: string) {
  let n = +s
  if (n == 1) return n
  return s + strSum((n - 1).toString())
}

console.log(strSum('5'))

// !Function expression

// ?function declaration (объявление функции)
function sayHi1() {
  alert("Привет");
}

// ?function expression (присваивание функции)
let sayHi2 = function () {
  alert("Привет");
};

console.log(sayHi1)
console.log(sayHi2)

// Функция это значение.Поэтому мы можем работать с ней так же, как и с другими видами значений.
// Мы можем скопировать функцию в другую переменную:

function sayHi() {   // (1) создаём
  console.log("Привет")
}
let func = sayHi;    // (2) копируем
func() // Привет     // (3) вызываем копию (работает)!
sayHi() // Привет    //     эта тоже все ещё работает (почему бы и нет)

// !!!Функции -«колбэки»

function ask(question: string, yes: Function, no: Function) {
  if (confirm(question)) yes()
  else no();
}

function showOk() {
  alert("Вы согласны.");
}

function showCancel() {
  alert("Вы отменили выполнение.");
}

// использование: функции showOk, showCancel передаются в качестве аргументов ask
// !ask("Вы согласны?", showOk, showCancel);
// !ask(
// "Вы согласны?",
//   function () { alert("Вы согласились."); },
//   function () { alert("Вы отменили выполнение."); }
// )
// !ask(
// "Вы согласны?",
//   () => alert("Вы согласились."),
//   () => alert("Вы отменили выполнение.")
// )

// ! Итого
// ? Функции – это значения.Они могут быть присвоены, скопированы или объявлены в любом месте кода.
// ? Если функция объявлена как отдельная инструкция в основном потоке кода, то это “Function Declaration”.
// ? Если функция была создана как часть выражения, то это “Function Expression”.
// ? Function Declaration обрабатываются перед выполнением блока кода.Они видны во всём блоке.
// ? Функции, объявленные при помощи Function Expression, создаются только когда поток выполнения достигает их.

// ! Стрелочные функции

let sum: Function | null = (a: number, b: number) => a + b
let epression = (a: number, b: number) => {
  a *= 2
  return a + b
}

/* Эта стрелочная функция представляет собой более короткую форму:

let sum = function(a, b) {
  return a + b;
};
*/

console.log(sum(1, 2)) // 3
sum = null

// Итого
// Стрелочные функции очень удобны для простых действий, особенно для однострочных.

// Они бывают двух типов:

// Без фигурных скобок: (...args) => expression – правая сторона выражения: функция вычисляет его и возвращает результат.Скобки можно не ставить, если аргумент только один: n => n * 2.
// С фигурными скобками: (...args) => { body } – скобки позволяют нам писать несколько инструкций внутри функции, но при этом необходимо явно вызывать return, чтобы вернуть значение.

let xz: any = 5
xz = "Вася"

let uName = ''
let toDos = [] as string[]

const appDiv = document.getElementById('app')
// if (appDiv) appDiv.innerHTML += `<p>Добро пожаловать на сайт</p>`
function render() {
  let isLogin = Boolean(uName)
  if (appDiv) appDiv.innerHTML = ''
  const pElelement = document.createElement('p')
  pElelement.textContent = uName ? `${uName}, добро пожаловать на сайт` : `Добро пожаловать на сайт`
  if (appDiv) appDiv.appendChild(pElelement)

  const button = document.createElement('button')
  button.textContent = isLogin ? 'LogOut' : 'Login'
  button.addEventListener('click', () => {
    uName = isLogin ? '' : 'Niko'
    toDos = !isLogin ? ['проснуться', 'позавтракать', 'умыться', 'работать', 'лечь спать'] : []
    render()
  })
  if (appDiv) appDiv.appendChild(button)
  if (isLogin) {
    const olElement = document.createElement('ol')
    // for (let i=0;i<toDos.length;i++) {
    //   const listElement = document.createElement('li')
    //   listElement.textContent = toDos[i]
    //   olElement.appendChild(listElement)
    // }
    for (let el of toDos) {
      const listElement = document.createElement('li')
      listElement.textContent = el
      olElement.appendChild(listElement)
    }
    if (appDiv) appDiv.appendChild(olElement)
  }
}

render()

const userO = {               // объект
  name: "John",             // под ключом "name" хранится значение "John"
  age: 30,                  // под ключом "age" хранится значение 30
  "likes birds": true,      // имя свойства из нескольких слов должно быть в кавычках
  'backgound-color': 'red',
  0: 10,
} as Record<string, any>

console.log(userO)
console.log({ ...userO })
console.log(userO.name)
console.log(userO[0])
console.log(userO['backgound-color'])


const key = 'backgound-color'
console.log(userO[key])

userO.isAdmin = true
console.log({ ...userO })

delete userO[0]
delete userO.isLogin
delete userO['backgound-color']
console.log({ ...userO })

function makeUser(name: string = '', age: number = 0) {
  return {
    // вместо такой записи, где мы отдельно прописываем имя свойства, а значение берём из одноимённой переменной
    // name:name,
    // age:age,
    // мы можем просто указать имена переменных
    // В таком случае имя переменной станет именем свойства, а её значение,- значением свойства
    name, // тоже самое, что и name:name
    age,  // тоже самое, что и age:age
    admin: false,
    key: 20,
    noValue: undefined,
  } as any
}

const usr1 = makeUser('Niko', 35)
console.log(usr1)

// При обращении к свойству, которого нет, возвращается undefined.Это позволяет просто проверить существование свойства:
// Для чего вообще нужен оператор in? Разве недостаточно сравнения с undefined ?

// В большинстве случаев прекрасно сработает сравнение с undefined.Но есть особый случай, когда оно не подходит и нужно использовать "in".


console.log('"age" in usr1', "age" in usr1)    // true, usr1.age существует
console.log('"blabla" in usr1', "blabla" in usr1) // false, usr1.blabla не существует
console.log('usr1.blabla === undefined', usr1.blabla === undefined) // true, usr1.blabla не существует
// Это когда свойство существует, но содержит значение undefined
console.log('"noValue" in usr1', "noValue" in usr1) // true, usr1.noValue существует
console.log('usr1.noValue === undefined', usr1.noValue === undefined) // true, usr1.noValue существует, но его значение = undefined
console.log('usr1.noValue === undefined', usr1['noValue'] === undefined) // true, usr1.noValue существует, но его значение = undefined

// Подобные ситуации случаются очень редко, так как undefined обычно явно не присваивается.Для «неизвестных» или «пустых» свойств мы используем значение null

// !Цикл "for..in"
// На каждой итерации цикла в переменную key попадают имена свойств объекта (строкой)
for (let key in usr1) {
  console.log('key', key, 'value', usr1[key])
}

// Получить все ключи объекта массивом
const keys = Object.keys(usr1)
console.log(keys)
console.log(Object.values(usr1))
console.log(Object.entries(usr1)[2])


// Итого
// Объекты – это ассоциативные массивы с рядом дополнительных возможностей.

// Они хранят свойства(пары ключ - значение), где:

// Ключи свойств должны быть строками или символами(обычно строками).
// Значения могут быть любого типа.
// Чтобы получить доступ к свойству, мы можем использовать:

// Запись через точку: obj.property.
// Квадратные скобки obj["property"].Квадратные скобки позволяют взять ключ из переменной, например, obj[varWithKey].
// Дополнительные операторы:

// Удаление свойства: delete obj.prop.
// Проверка существования свойства: "key" in obj.
// Перебор свойств объекта: цикл for for (let key in obj).
// То, что мы изучали в этой главе, называется «простым объектом» («plain object») или просто Object.

// В JavaScript есть много других типов объектов:

// Array для хранения упорядоченных коллекций данных,
// Date для хранения информации о дате и времени,
// Error для хранения информации об ошибке.
// … и так далее.
// У них есть свои особенности, которые мы изучим позже.Иногда люди говорят что - то вроде «тип данных Array» или «тип данных Date», но формально они не являются отдельными типами, а относятся к типу данных Object.Они лишь расширяют его различными способами.

// Задание
// Создать объект, описывающий прямоугольник(хранит коор -
// динаты левой верхней и правой нижней точек), и написать следу -
// ющие функции для работы с таким объектом.

type Rect = {
  x0: number,
  y0: number,
  x1: number,
  y1: number,
}

const rect: Rect = {
  x0: 50,
  y0: 50,
  x1: 100,
  y1: 100,
}

const rectDiv = document.getElementById('rect')

const moveLeftTopButton = document.getElementById('moveLeftTop')
moveLeftTopButton?.addEventListener('click', () => { changeRectPosition(rect, -10, -10) })
const moveTopButton = document.getElementById('moveTop')
moveTopButton?.addEventListener('click', () => { changeRectPositionY(rect, -10) })
const moveRightTopButton = document.getElementById('moveRightTop')
moveRightTopButton?.addEventListener('click', () => { changeRectPosition(rect, 10, -10) })
const moveLeftButton = document.getElementById('moveLeft')
moveLeftButton?.addEventListener('click', () => { changeRectPositionX(rect, -10) })
const moveRightButton = document.getElementById('moveRight')
moveRightButton?.addEventListener('click', () => { changeRectPositionX(rect, 10) })
const moveLeftBottomButton = document.getElementById('moveLeftBottom')
moveLeftBottomButton?.addEventListener('click', () => { changeRectPosition(rect, -10, 10) })
const moveBottomButton = document.getElementById('moveBottom')
moveBottomButton?.addEventListener('click', () => { changeRectPositionY(rect, 10) })
const moveRightBottomButton = document.getElementById('moveRightBottom')
moveRightBottomButton?.addEventListener('click', () => { changeRectPosition(rect, 10, 10) })

const squeezeX = document.getElementById('squeezeX')
squeezeX?.addEventListener('click', () => { changeRectWidth(rect, -10) })
const expandX = document.getElementById('expandX')
expandX?.addEventListener('click', () => { changeRectWidth(rect, 10) })
const squeezeY = document.getElementById('squeezeY')
squeezeY?.addEventListener('click', () => { changeRectHeight(rect, -10) })
const expandY = document.getElementById('expandY')
expandY?.addEventListener('click', () => { changeRectHeight(rect, 10) })


console.log(rectDiv)
function renderRect(rect: Rect) {
  if (rectDiv) {
    rectDiv.style.top = rect.y0 + 'px'
    rectDiv.style.left = rect.x0 + 'px'
    rectDiv.style.width = getRectWidth(rect) + 'px'
    rectDiv.style.height = getRectHeight(rect) + 'px'
  }
}
renderRect(rect)

// 1 Функция принимает объект - прямоугольник и выводит
// информацию о нем(где какая точка расположена).

function showRectInfo(rect: Rect) {
  console.log(`top-left (${rect.x0}, ${rect.y0}) bootom-rigth (${rect.x1}, ${rect.y1})`)
}
showRectInfo(rect)

// 2 Функция принимает объект - прямоугольник и возвращает
// его ширину.

function getRectWidth(rect: Rect) {
  return rect.x1 - rect.x0
}

// 3 Функция принимает объект - прямоугольник и возвращает
// его высоту.

function getRectHeight(rect: Rect) {
  return rect.y1 - rect.y0
}

// 4 Функция принимает объект - прямоугольник и возвращает
// его площадь.

function getRectArea(rect: Rect) {
  return getRectWidth(rect) * getRectHeight(rect)
}
console.log(`площадь прямоугольника ${getRectArea(rect)}px`)

// 5 Функция принимает объект - прямоугольник и возвращает
// его периметр.

function getRectPerimetr(rect: Rect) {
  return getRectWidth(rect) * 2 + getRectHeight(rect) * 2
}
console.log(`периметр прямоугольника ${getRectPerimetr(rect)}px`)

// 6 Функция изменения ширины прямоугольника.Она прини -
// мает объект - прямоугольник и на сколько единиц изменить
// ширину.

function changeRectWidth(rect: Rect, n: number) {
  rect.x1 += n
  renderRect(rect)
}

// 7 Функция изменения высоты прямоугольника.Она прини -
// мает объект - прямоугольник и на сколько единиц изменить
// высоту.

function changeRectHeight(rect: Rect, n: number) {
  rect.y1 += n
  renderRect(rect)
}

// 8 Функция изменения ширины и высоты прямоугольника.
// Она принимает объект - прямоугольник и два значения –
// для изменения ширины и высоты.

function changeRectWidthAndHeight(rect: Rect, x: number, y: number) {
  changeRectWidth(rect, x)
  changeRectHeight(rect, y)
  renderRect(rect)
}

// 9 Функция смещения прямоугольника по оси X.Она при -
// нимает объект - прямоугольник и на сколько единиц его
// сдвинуть.

function changeRectPositionX(rect: Rect, n: number) {
  rect.x0 += n
  rect.x1 += n
  renderRect(rect)
}

// 10 Функция смещения прямоугольника по оси Y.Она при -
// нимает объект - прямоугольник и на сколько единиц его
// сдвинуть.

function changeRectPositionY(rect: Rect, n: number) {
  rect.y0 += n
  rect.y1 += n
  renderRect(rect)
}

// 11 Функция смещения прямоугольника и по оси X и по
// оси Y.Она принимает объект - прямоугольник и два значе -
// ния: сдвиг по оси X и сдвиг по оси Y.

function changeRectPosition(rect: Rect, x: number, y: number) {
  changeRectPositionX(rect, x)
  changeRectPositionY(rect, y)
  renderRect(rect)
}

// 12 Функция для проверки, находится ли точка внутри пря -
// моугольника.Она принимает объект - прямоугольник и
// координаты точки.

// !Переменная, которой присвоен объект, хранит не сам объект, а его «адрес в памяти» – другими словами, «ссылку» на него.

// !Клонирование и объединение, Object.assign

user = {
  name: "John",
  age: 30,
  drivePermission: {
    A: true,
    B: true,
    C: false
  },
  // canDriveC() {
  //   return this.drivePermission.C
  // }
}

let clone = {} as any // новый пустой объект

// 1 вариант клонирования - перебор в цилке. Для объектов с глубокой вложенностью необходима рекурсия
// Малоиспользуемый вариант
// for (let key in user) {
//   clone[key] = user[key]
// }

// 2 метод - Object.assign
// Object.assign(clone, user, {drivePermission:{...user.drivePermission}})



// 3 метод - Spred оператор (оператор расширения)
// clone = { ...user, drivePermission: { ...user.drivePermission } }

// 4 метод - преобразование в JSON и обратно. Не копирует методы объекта
// clone = JSON.parse(JSON.stringify(user))

// 5 structuredClone() (При копировании метода вызывается ошибка, копирует вложенные объекты)
clone = structuredClone(user)

// теперь clone это полностью независимый объект с тем же содержимым
clone.name = "Pete" // изменим в нём данные
clone.drivePermission.C = true
console.log(user) // все ещё John в первоначальном объекте
console.log(clone) // все ещё John в первоначальном объекте

// !Object.assign(dest, [src1, src2, src3...])
// Первый аргумент dest — целевой объект.
// Остальные аргументы src1, ..., srcN(может быть столько, сколько необходимо) являются исходными объектами
// Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest.Другими словами, свойства всех аргументов, начиная со второго, копируются в первый объект.
// Возвращает объект dest.

// !Объекты присваиваются и копируются по ссылке.Другими словами, переменная хранит не «значение объекта», а «ссылку» (адрес в памяти) на это значение.Таким образом, копирование такой переменной или передача её в качестве аргумента функции копирует эту ссылку, а не сам объект.

// !Все операции с использованием скопированных ссылок(например, добавление / удаление свойств) выполняются с одним и тем же объектом.

// !Чтобы создать «реальную копию» (клон), мы можем использовать Object.assign для так называемой «поверхностной копии» (вложенные объекты копируются по ссылке) или функцию «глубокого клонирования», такую как _.cloneDeep(obj).

// !Сборка мусора

// ?Сборка мусора выполняется автоматически.Мы не можем ускорить или предотвратить её.
// ?Объекты сохраняются в памяти, пока они достижимы.
// ?Если на объект есть ссылка – вовсе не факт, что он является достижимым(из корня): набор взаимосвязанных объектов может стать недоступен в целом, как мы видели в примере выше.

// Таким образом все пользователи будут создвать свою функцию, которая занимает место в памяти
user.sayHi = function () {
  console.log("Привет!")
}
console.log({ ...user })

user.sayHi() // Привет!


// добавим функцию в качестве метода
// Таким образом все пользователи будут ссылаться на одну функцию
user.sayHi = sayHi
console.log({ ...user })

user.sayHi() // Привет!

// !Функцию, которая является свойством объекта, называют методом этого объекта.

// эти объекты делают одно и то же

user = {
  sayHi: function () {
    alert("Привет");
  }
}

// сокращённая запись выглядит лучше, не так ли?
// Лучше использовать такую запись
user = {
  name: "John",
  sayHi() { // то же самое, что и "sayHi: function(){...}"
    alert("Привет");
  }
}

// Ключевое слово «this» в методах
// !!!Значение this – это объект «перед точкой», который используется для вызова метода.

// !«this» не является фиксированным
// В JavaScript ключевое слово «this» ведёт себя иначе, чем в большинстве других языков программирования.Его можно использовать в любой функции, даже если это не метод объекта.

// Функция написанная специально, чтобы использоваться как метод объекта
// !"this" внутри функции - это объект "перед точкой"
function sayName(this: any) {
  console.log(this)
}

const bus = [
  { name: 'sfd' },
  { name: 'sdgtrey' },
  { name: 'uytty' },
  { name: 'mvmbnmytj' },
  { name: 'jkljlyu' },
  { bag: '20*20*30' }
] as any

for (let i = 0; i < bus.length; i++) {
  if (bus[i].name) {
    bus[i].sayName = sayName
    bus[i].sayName()
  }
}

// В строгом режиме ("use strict") в таком коде значением this будет являться undefined
sayName()

// !В JavaScript this является «свободным», его значение вычисляется в момент вызова метода и не зависит от того, где этот метод был объявлен, а скорее от того, какой объект вызывает метод(какой объект стоит «перед точкой»)

// У стрелочных функций нет «this»
// Стрелочные функции особенные: у них нет своего «собственного» this.Если мы ссылаемся на this внутри такой функции, то оно берётся из внешней «нормальной» функции.

// Например, здесь arrow() использует значение this из внешнего метода user.sayHi():

user = {
  firstName: "Ilya",
  sayHi() {
    let arrow = () => console.log(this.firstName)
    arrow()
  },
  // TS подсказывает об ошибке
  // arrowSayHi: () => alert(this.firstName)
};

user.sayHi() // Ilya
// Это особенность стрелочных функций.Она полезна, когда мы на самом деле не хотим иметь отдельное this, а скорее хотим взять его из внешнего контекста.Позже в главе Повторяем стрелочные функции мы увидим больше примеров на эту тему.

// ?Функции, которые находятся в свойствах объекта, называются «методами».
// ?Методы позволяют объектам «действовать»: object.doSomething().
// ?Методы могут ссылаться на объект через this.
// ?Значение this определяется во время исполнения кода.

// ?При объявлении любой функции в ней можно использовать this, но этот this не имеет значения до тех пор, пока функция не будет вызвана.
// ?Функция может быть скопирована между объектами(из одного объекта в другой).
// ?Когда функция вызывается синтаксисом «метода» – object.method(), значением this во время вызова является object.
// ?Также ещё раз заметим, что стрелочные функции являются особенными – у них нет this.Когда внутри стрелочной функции обращаются к this, то его значение берётся извне.

let ladder = {
  step: 0,
  up() {
    this.step++
    return this
  },
  down() {
    this.step--
    return this
  },
  showStep: function () { // показывает текущую ступеньку
    console.log(this.step)
    return this
  }
}

ladder.up().up().down().showStep().down().showStep()

// Создайте объект calculator(калькулятор) с тремя методами:

// read()(читать) запрашивает два значения и сохраняет их как свойства объекта.
// sum()(суммировать) возвращает сумму сохранённых значений.
// mul()(умножить) перемножает сохранённые значения и возвращает результат.

const calculator = {
  a: 0,
  b: 0,
  read() {
    this.a = +(prompt('Введите первое число') as string)
    this.b = +(prompt('Введите второе число') as string)
  },
  sum() {
    return this.a + this.b
  },
  mul() {
    return this.a * this.b
  }
}

// calculator.read()
// console.log(calculator.sum())
// console.log(calculator.mul())


const carInfo: any = {
  car0: {
    manufacturer: 'Ferrari',
    model: 'Spyder',
    yearOfRelease: 1999,
    averageSpeed: 150,
  },
  car1: {
    manufacturer: 'Toyota',
    model: 'Camry',
    yearOfRelease: 2020,
    averageSpeed: 60,
  },
  car2: {
    manufacturer: 'Honda',
    model: 'Civic',
    yearOfRelease: 2019,
    averageSpeed: 55,
  },
}
//   Функция для подсчета необходимого времени для пре-
//   одоления переданного расстояния со средней скоростью.
//   Учтите, что через каждые 4 часа дороги водителю необхо-
//   димо делать перерыв на 1 час.
function caclOvercomingTheDistance(distance: number, carInfo: any) {
  for (let carKey in carInfo) {
    const car = carInfo[carKey]
    const timeWithoutStops = distance / car.averageSpeed
    const timeWithStops = timeWithoutStops + Math.floor(timeWithoutStops / 4)
    console.log(`На автомобиле ${car.manufacturer} ${car.model} ${car.yearOfRelease} года выпуска, для преодоления дистанции в ${distance} км. с олтдыхом каждые 4 часа пути, потребуется ${timeWithStops.toFixed(2)} ч.`)
    console.log(`Без остановок эту дистанцию можно преодолеть за ${timeWithoutStops.toFixed(2)} ч.`)
  }
}
caclOvercomingTheDistance(800, carInfo)

// !Каждый примитив имеет свой собственный «объект - обёртку», которые называются: String, Number, Boolean, Symbol и BigInt.Таким образом, они имеют разный набор методов.

// Примитивы остаются примитивами
// Язык позволяет осуществлять доступ к методам и свойствам строк, чисел, булевых значений и символов
// Чтобы это работало, при таком доступе создаётся специальный «объект - обёртка», который предоставляет нужную функциональность, а после удаляется

// К примеру, существует метод str.toUpperCase(), который возвращает строку в верхнем регистре.

str = "Привет"

console.log(str.toUpperCase()) // ПРИВЕТ

// Очень просто, не правда ли ? Вот, что на самом деле происходит в str.toUpperCase():

// ?Строка str – примитив.В момент обращения к его свойству, создаётся специальный объект, который знает значение строки и имеет такие полезные методы, как toUpperCase().
// ?Этот метод запускается и возвращает новую строку(показывается в alert).
// ?Специальный объект удаляется, оставляя только примитив str.
// !Получается, что примитивы могут предоставлять методы, и в то же время оставаться «лёгкими».

// !Движок JavaScript сильно оптимизирует этот процесс.Он даже может пропустить создание специального объекта.Однако, он всё же должен придерживаться спецификаций и работать так, как будто он его создаёт.

// !null / undefined не имеют методов
// ?Особенные примитивы null и undefined являются исключениями.У них нет соответствующих «объектов - обёрток», и они не имеют никаких методов.В некотором смысле, они «самые примитивные».

const carObjArr: any = {
  0: {
    manufacturer: 'Ferrari',
    model: 'Spyder',
    yearOfRelease: 1999,
    averageSpeed: 150,
  },
  1: {
    manufacturer: 'Toyota',
    model: 'Camry',
    yearOfRelease: 2020,
    averageSpeed: 60,
  },
  2: {
    manufacturer: 'Honda',
    model: 'Civic',
    yearOfRelease: 2019,
    averageSpeed: 55,
  },
  str: 'dsa',
  obj: {},
  num: 198
}
// Получить доступ к объекту
console.log('carObjArr', carObjArr)
// Получаем все ключи объекта через цикл
for (let carKey in carObjArr) {
  const car = carObjArr[carKey] // доступ к объекту
  if (typeof carObjArr[carKey] == 'object') {
    console.log('carKey', carKey)
    console.log('carObjArr[' + carKey + ']', carObjArr[carKey])
  }
}

console.log('Object keys', Object.keys(carObjArr))
console.log('Object values', Object.values(carObjArr))
console.log('Object entries', Object.entries(carObjArr))

console.log(carObjArr['str'], carObjArr.str) //carObjArr["ada"] и carObjArr.ada работают одинаково
// Мы можем обратиться к свойству объекта через точку, либо через квадратные скобки

const carArr: any = [
  {
    manufacturer: 'Ferrari',
    model: 'Spyder',
    yearOfRelease: 1999,
    averageSpeed: 150,
  },
  {
    manufacturer: 'Toyota',
    model: 'Camry',
    yearOfRelease: 2020,
    averageSpeed: 60,
  },
  {
    manufacturer: 'Honda',
    model: 'Civic',
    yearOfRelease: 2019,
    averageSpeed: 55,
  },
]
console.log('carObjArr', carObjArr)
console.log('carArr', carArr)

// Перебор объектов в массиве
for (let car of carArr) {
  console.log('car', car)
}

const nums = [46, 654894, 321, 65465, 32, 4869, 431, 346598]
console.log('nums', nums)

console.log('for of')
for (let num of nums) {
  console.log('num', num)
}
console.log('classic for')
for (let i = 0; i < nums.length; i++) {
  console.log('num', nums[i])
}

const wodrStr = 'word'
console.log('for of')
for (let l of wodrStr) {
  console.log('letter', l)
}
console.log('classic for')
for (let i = 0; i < wodrStr.length; i++) {
  console.log('letter', wodrStr[i])
}

// Циклы for ... in и for ... of проходят по всем значениям
// for ... in обходит ключи объекта и помещает их значения в переменную
// for ... of обходит элементы массива и помещает их в переменную
// Классический цикл for предоставляет более гибкий доступ к итерируемым данным

// TS автоматически при присвоении считывает тип данных элементов
// const numsArr: number[]
const numsArr = [1, 2, 3, 5, 4, 8]
// const strsArr: string[]
const strsArr = ['1', '2', '3', '5', "4", "8"]

// const objArr: {
// a: number;
// b: number;
// c: number;
// }[]
const objArr = [
  { a: 1, b: 2, c: 3 },
  { a: 1, b: 2, c: 3 },
  { a: 1, b: 2, c: 3 },
  { a: 1, b: 2, c: 3 },
] as Record<string, number | string>[]
// as any[]
objArr[0].d = '140'

// Создать массив «Список покупок». Каждый элемент массива
// является объектом, который содержит название продукта, необ-
// ходимое количество и куплен или нет. Написать несколько функ-
// ций для работы с таким массивом.
const listProducts = [
  {
    name: 'Pasta',
    quantity: 2,
    purchased: true,
  },
  {
    name: 'Meat',
    quantity: 3,
    purchased: false,
  },
  {
    name: 'Sauce',
    quantity: 1,
    purchased: false,
  },
]

const nameInput = document.getElementById('name') as HTMLInputElement
const quantityInput = document.getElementById('quantity') as HTMLInputElement
const addButton = document.getElementById('add') as HTMLElement
const purshasesDiv = document.getElementById('purshases') as HTMLElement

purshasesDiv.addEventListener('click', (event) => {
  const target = event.target as HTMLElement
  if (target.tagName != 'BUTTON') return
  togglePurchased(listProducts, target.dataset.name)
})

addButton.addEventListener('click', () => {
  addPurchase(listProducts, nameInput.value, +quantityInput.value)
  nameInput.value = ''
  quantityInput.value = ''
})

function showProducts(listProducts: any) {
  purshasesDiv.innerHTML = ''
  // Вывод некупленных продуктов
  purshasesDiv.innerHTML += '<p>Некупленные продукты:</p><ol>'
  for (let product of listProducts) {
    if (!product.purchased)
      purshasesDiv.innerHTML += `<li>Название: ${product.name}, Количество: ${product.quantity} 
    <button data-name="${product.name}">V</button></li>`
  }
  purshasesDiv.innerHTML += '</ol>'

  // Вывод купленных продуктов
  purshasesDiv.innerHTML += '<p>Купленные продукты:</p><ol>'
  for (let product of listProducts) {
    if (product.purchased)
      purshasesDiv.innerHTML += `<li>Название: ${product.name}, Количество: ${product.quantity}
    <button data-name="${product.name}">X</button></li>`
  }
  purshasesDiv.innerHTML += '</ol>'
}
showProducts(listProducts)



// 2
// Добавление покупки в список. Учтите, что при добавлении
// покупки с уже существующим в списке продуктом, необ-
// ходимо увеличивать количество в существующей покупке,
// а не добавлять новую.    
function addPurchase(listProducts: any, productName: string, quantity: number) {
  for (let product of listProducts) {
    if (product.name == productName) {
      product.quantity += quantity
      showProducts(listProducts)
      return
    }
  }
  listProducts.push({
    name: productName,
    quantity,
    purchased: false,
  })
  showProducts(listProducts)
}
// 3
// Покупка продукта. Функция принимает название продукта
// и отмечает его как купленный.
function togglePurchased(listProducts: any, productName: string | undefined) {
  for (let product of listProducts) {
    if (product.name == productName) {
      product.purchased = !product.purchased
      showProducts(listProducts)
    }
  }
}


// Самый простой способ очистить массив – это arr.length = 0

// Массивы могут содержать элементы, которые тоже являются массивами.Это можно использовать для создания многомерных массивов, например, для хранения матриц:

let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
]

console.log(matrix[1][1]) // 5, центральный элемент
console.log(matrix[2][2]) // 9

// !Давайте ещё раз напомним правила:

// Два объекта равны друг другу == только в том случае, если они ссылаются на один и тот же объект.
// Если один из аргументов == является объектом, а другой – примитивом, то объект преобразуется в примитив, как описано в главе Преобразование объектов в примитивы.
// …За исключением null и undefined, которые равны == друг другу и ничему больше.

// @ts-ignore
console.log('[1,2,3]==[1,2,3]', [1, 2, 3] == [1, 2, 3]) // false Массивы- это объекты, а объекты равны друг другу только по ссылке
console.log('[1, 2, 3].toString() == [1, 2, 3].toString()', [1, 2, 3].toString() == [1, 2, 3].toString()) // true Подходит только для массивов с примитивами
console.log('[{ a: 10 }, 2, 3].toString() == [{ a: 20 }, 2, 3].toString()', [{ a: 10 }, 2, 3].toString() == [{ a: 20 }, 2, 3].toString()) // true [object Object]. Не подходит для массивов с объектами
console.log('[{ a: 10 }, 2, 3].toString()', [{ a: 10 }, 2, 3].toString())


// Так как же сравнить массивы ?

// Это просто: не используйте оператор ==.Вместо этого сравните их по элементам в цикле или используя методы итерации, описанные в следующей главе.

function arrayCompare(arr1: any[], arr2: any[], strict: boolean) {
  if (arr1.length != arr2.length) return false
  for (let i = 0; i < arr1.length; i++) {
    if ((typeof arr1[i] == 'object' && typeof arr2[i] != 'object') || (typeof arr1[i] != 'object' && typeof arr2[i] == 'object')) return false
    if (typeof arr1[i] == 'object') {
      const entr1 = Object.entries(arr1[i])
      const entr2 = Object.entries(arr2[i])
      if (entr1.length != entr2.length) return false
      for (let j = 0; j < entr1.length; j++) {
        if (!arrayCompare(entr1[j], entr2[j], strict)) return false
      }
    }
    else {
      if (strict) {
        if (arr1[i] !== arr2[i]) return false
      } else {
        if (arr1[i] != arr2[i]) return false
      }
    }
  }
  return true
}

console.log(arrayCompare([1, 2, 3, { a: 20, b: { c: '5' } }], [1, 2, 3, { a: 20, b: { c: 5 } }], false))

// !Методы массивов

// !Метод arr.splice(str) – это универсальный «швейцарский нож» для работы с массивами.Умеет всё: добавлять, удалять и заменять элементы.
// ?Splice - сращивание
// arr.splice(start[, deleteCount, elem1, ..., elemN])
// ?Он изменяет arr начиная с индекса start: удаляет deleteCount элементов и затем вставляет elem1, ..., elemN на их место.Возвращает массив из удалённых элементов.

let tempArr = [1, 2, 3, 5, 4, 8]

// !Удаление
console.log('origin', [...tempArr])
console.log('deleted tempArr.splice(1)', tempArr.splice(1)) // Если передать только индекс начала (start), удалятся все элементы, начиная с этого индекса
console.log('result', tempArr)

tempArr = [1, 2, 3, 5, 4, 8]
console.log('deleted tempArr.splice(1,3)', tempArr.splice(1, 3)) // Удаляем количество элементов (deleteCount), начиная с индекса (start)
console.log('result', tempArr)

// !Добавление
tempArr = [1, 2, 3, 5, 4, 8]
console.log('deleted tempArr.splice(1,0,5,8,9)', tempArr.splice(1, 0, 5, 8, 9)) // Удаляем 0 элементов (deleteCount), начиная с индекса (start) добавлем элементы, переданные параметрами в функцию, начиная с 3его (elem1, ..., elemN)
console.log('result', tempArr)

// ?Добавление перед последним значением
tempArr = [1, 2, 3, 5, 4, 8]
console.log('deleted tempArr.splice(-1,0,7)', tempArr.splice(-1, 0, 7)) // Удаляем 0 элементов (deleteCount), начиная с индекса (start) (-1 это последний индекс) добавлем элементы, переданные параметрами в функцию, начиная с 3его (elem1, ..., elemN)
console.log('result', tempArr)

// !Добавление и удаление
tempArr = [1, 2, 3, 5, 4, 8]
console.log('deleted tempArr.splice(1,4,5,8,9)', tempArr.splice(1, 4, 5, 8, 9)) // Удаляем 4 элемента (deleteCount), начиная с индекса (start) добавлем элементы, переданные параметрами в функцию, начиная с 3его (elem1, ..., elemN)
console.log('result', tempArr)

tempArr = [1, 2, 3, 5, 4, 8]
console.log('deleted tempArr.splice(0,3,"sdfdsf",{a:20})', (tempArr as any[]).splice(0, 3, "sdfdsf", { a: 20 }))
console.log('result', tempArr)

// ?Slice - срез
// arr.slice([start], [end])
// Он возвращает новый массив, в который копирует все элементы с индекса start до end(не включая end).start и end могут быть отрицательными, в этом случае отсчёт позиции будет вестись с конца массива.

tempArr = [1, 2, 3, 5, 4, 8]
console.log('origin', [...tempArr])
console.log('result tempArr.slice()', tempArr.slice()) // получаем копию массива. Идентично [...tempArr]
// Если параметр end не указан, срез идёт до конца массива
console.log('result tempArr.slice(3)', tempArr.slice(3)) // получаем срез массива, начиная с 3го индекса
console.log('result tempArr.slice(3,5)', tempArr.slice(3, 5)) // получаем срез массива, начиная с 3го индекса до 5го, не включая его 

// ?concat - объединение
// Метод arr.concat создаёт новый массив, в который копирует данные из других массивов и дополнительные значения.
// arr.concat(arg1, arg2...)

// Он принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.
// В результате – новый массив, включающий в себя элементы из arr, затем arg1, arg2 и так далее.
// Если аргумент argN – массив, то копируются все его элементы.Иначе копируется сам аргумент.

let arr = [1, 2]

console.log('arr', arr) // 1,2,3,4
// создать массив из: arr и [3,4]
console.log('arr.concat([3, 4])', arr.concat([3, 4])) // 1,2,3,4

// создать массив из: arr и [3,4] и [5,6]
console.log('arr.concat([3, 4], [5, 6])', arr.concat([3, 4], [5, 6])) // 1,2,3,4,5,6

// создать массив из: arr и [3,4], потом добавить значения 5 и 6
console.log('arr.concat([3, 4], 5, 6)', arr.concat([3, 4], 5, 6)) // 1,2,3,4,5,6

// !Перебор: forEach
// ?Метод arr.forEach позволяет запускать функцию для каждого элемента массива.
// В функции доступен сам элемент, его индекс и весь массив

// arr.forEach(function (el, i, arr) {
arr.forEach((item, index, array) => array[index] = item ** 2)
console.log(arr)

// Примерная реализация метода forEach
function forEach(arr: any[], fn: Function) {
  for (let i = 0; i < arr.length; i++) {
    fn(arr[i], i, arr)
  }
}

// forEach(arr, function(item:any, index:number, array:any[]) {
//   console.log([item, index, array])
// })

// !Поиск
// ?indexOf / lastIndexOf и includes
// Так же применимо к строкам

// indexOf / lastIndexOf и includes
// У методов arr.indexOf и arr.includes одинаковый синтаксис и они делают по сути то же самое, что и их строковые аналоги, но работают с элементами вместо символов:

// arr.indexOf(item, from) ищет item начиная с индекса from и возвращает номер индекса, на котором был найден искомый элемент, в противном случае - 1.

// arr.includes(item, from) ищет item начиная с индекса from и возвращает true, если поиск успешен.
// Обычно эти методы используются только с одним аргументом: искомым item.По умолчанию поиск ведется с начала.

arr = ['sdf', 0, 5, 0, true, 5, 8, 2, 0, 56, 0, 58, 0] as any[]
console.log(arr)
console.log('arr.indexOf(0)', arr.indexOf(0)) // Ищем индекс значения 0 в массиве
console.log('arr.indexOf(0,2)', arr.indexOf(0, 2))  // Ищем индекс значения 0 в массиве, начиная с индекса 2
console.log('arr.indexOf(false)', (arr as any[]).indexOf(false))  // Ищем индекс значения false в массиве
console.log('arr.includes(0)', arr.includes(0))  // Есть ли в массиве занчение 0
console.log('arr.includes(0,4)', arr.includes(0, 4))  // Есть ли в массиве занчение 0, начиная с индекса 4

function indexOf(arr: any[], val: any) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] == val) return i
  }
  return -1
}


console.log('Найдём все индексы значения 0')
i = 0
do {
  i = arr.indexOf(0, i)
  if (i != -1) {
    console.log(i)
    i++
  }
} while (i != -1)

// Если мы хотим проверить наличие элемента в массиве и нет необходимости знать его индекс, предпочтительно использовать arr.includes

// !Преобразование массива

// !map
// ?Метод arr.map является одним из наиболее полезных и часто используемых.
// Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.

let mapArr = ["Бильбо", "Гэндальф", "Назгул"]
let mapObjArr = [
  { name: "Бильбо", atk: 10, },
  { name: "Гэндальф", atk: 50, },
  { name: "Назгул", atk: 40, },
]
console.log(mapArr)
console.log(mapArr.map(el => el.toUpperCase()))
console.log(mapArr.map(el => el.length))
console.log(mapObjArr.map(el => el.name))
console.log(mapObjArr.map(el => el.atk))
console.log(mapObjArr.map(el => 'Сила ' + el.name + ' равна ' + el.atk))

// !sort(fn)
// ?Вызов arr.sort() сортирует массив на месте, меняя в нём порядок элементов.
// ?Он также возвращает отсортированный массив, но обычно возвращаемое значение игнорируется, так как изменяется сам arr.

// Функция сравнения может вернуть любое число
// На самом деле от функции сравнения требуется любое положительное число, чтобы сказать «больше», и отрицательное число, чтобы сказать «меньше».

arr = [1, 2, 15, 657, 2, 435, 756, 23, 3]

arr.sort((a, b) => a - b) // от порядка значений зависит порядок сортировки
console.log(arr)
// Метод reverse разворачивает массив
console.log(arr.reverse())
const strMapArr = mapArr.slice()
strMapArr.push('гэндальф')
console.log(strMapArr.sort((a, b) => a.localeCompare(b)))

let names = 'Вася, Петя, Маша'

// !Метод str.split(delim) именно это и делает.Он разбивает строку на массив по заданному разделителю delim

console.log(names.split(', '))

// !Вызов arr.join(glue) делает в точности противоположное split.Он создаёт строку из элементов arr, вставляя glue между ними

console.log(names.split(', ').join('; '))


function anyCountParams(...args: any[]) {
  let sum = 0
  args.forEach(el => sum += el)
  return sum
}

console.log(anyCountParams(1, 2, 4, 6, 7, 89, 45, 532, 5254, 43234,))

// let result = arr.find(function (item, index, array) {
//   если true - возвращается текущий элемент и перебор прерывается
//   если все итерации оказались ложными, возвращается undefined
// });
// Функция вызывается по очереди для каждого элемента массива:

// item – очередной элемент.
// index – его индекс.
// array – сам массив.
// Если функция возвращает true, поиск прерывается и возвращается item.Если ничего не найдено, возвращается undefined.

let users = [
  { id: 1, name: "Вася" },
  { id: 2, name: "Петя" },
  { id: 3, name: "Маша" },
]

let findUser = users.find(item => item.id == 3)
console.log(findUser)

// Пример реализации метода массива find
function find(arr: any[], fn: Function) {
  for (let i = 0; i < arr.length; i++) {
    if (fn(arr[i], i, arr)) return arr[i]
  }
}

// let result = arr.findIndex(function (item, index, array) {
//   если true - возвращается индекс текущего элемента и перебор прерывается
//   если все итерации оказались ложными, возвращается -1
// });
// Функция вызывается по очереди для каждого элемента массива:
// Если функция возвращает true, поиск прерывается и возвращается index.Если ничего не найдено, возвращается -1.

let findUserIndex = users.findIndex(item => item.id == 3)
console.log(findUserIndex)

// Пример реализации метода массива filter
function findIndex(arr: any[], fn: Function) {
  for (let i = 0; i < arr.length; i++) {
    if (fn(arr[i], i, arr)) return i
  }
  return -1
}

// Синтаксис схож с find, но filter возвращает массив из всех подходящих элементов, или пустой массив
// let results = arr.filter(function (item, index, array) {
//   если `true` -- элемент добавляется к results и перебор продолжается
//   возвращается пустой массив в случае, если ничего не найдено
// })

let findUsers = users.filter(item => item.name.includes('я'))
console.log(findUsers)

// Пример реализации метода массива filter
function filter(arr: any[], fn: Function) {
  const newArr = [] as any
  for (let i = 0; i < arr.length; i++) {
    if (fn(arr[i], i, arr)) newArr.push(arr[i])
  }
  return newArr
}

// Методы arr.reduce и arr.reduceRight похожи на методы выше, но они немного сложнее.Они используются для вычисления единого значения на основе всего массива.

// let value = arr.reduce(function (accumulator, item, index, array) {
//   ...
// }, [initial]);

// Функция применяется по очереди ко всем элементам массива и «переносит» свой результат на следующий вызов.

//   Аргументы:
//   accumulator – результат предыдущего вызова этой функции, равен initial при первом вызове(если передан initial),
//   item – очередной элемент массива,
//   index – его позиция,
//   array – сам массив.

// При вызове функции результат её предыдущего вызова передаётся на следующий вызов в качестве первого аргумента.

// Так, первый аргумент является по сути аккумулятором, который хранит объединённый результат всех предыдущих вызовов функции.По окончании он становится результатом reduce.

arr = [1, 2, 4, 6, 7, 89, 45, 532, 5254, 43234]
let reduceSum = 0
arr.forEach(el => reduceSum += el)
console.log(reduceSum)

reduceSum = arr.reduce((a, el) => a *= el)
console.log(reduceSum)

// objArr = [
//   { a: 1, b: 2, c: 3 },
//   { a: 1, b: 2, c: 3 },
//   { a: 1, b: 2, c: 3 },
//   { a: 1, b: 2, c: 3 },
// ] as Record<string, number | string>[]

const reduceObjSum = objArr.reduce((a, el: any) => a += el.c, 0)
console.log(reduceObjSum)

function reduceObjFunc(a: any, el: any, i: number) {
  a[i] = el
  // a[el.id] = el
  return a
}

const reduceObj = objArr.reduce(reduceObjFunc, {})
console.log(reduceObj)

const newObj = {} as any
for (let el of objArr) {
  newObj[el.a] = el
}
for (let i = 0; i < objArr.length; i++) {
  newObj[objArr[i].a] = objArr[i]
}

// Array.isArray
// Массивы не образуют отдельный тип языка.Они основаны на объектах.
// Поэтому typeof не может отличить простой объект от массива:

console.log('typeof {}', typeof {}) // object
console.log('typeof []', typeof []) // тоже object

// …Но массивы используются настолько часто, что для этого придумали специальный метод: Array.isArray(value).Он возвращает true, если value массив, и false, если нет.

console.log('Array.isArray({})', Array.isArray({})) // false
console.log('Array.isArray([])', Array.isArray([])) // true


// Итого
// !Шпаргалка по методам массива:

// ?Для добавления / удаления элементов:

// push(...items) – добавляет элементы в конец,
// pop() – извлекает элемент с конца,
// shift() – извлекает элемент с начала,
// unshift(...items) – добавляет элементы в начало.
// splice(pos, deleteCount, ...items) – начиная с индекса pos удаляет deleteCount элементов и вставляет items.
// slice(start, end) – создаёт новый массив, копируя в него элементы с индекса start до end(не включая end).
// concat(...items) – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items.Если какой - то из items является массивом, тогда берутся его элементы.

// ?Для поиска среди элементов:

// indexOf / lastIndexOf(item, pos) – ищет item, начиная с позиции pos, и возвращает его индекс или - 1, если ничего не найдено.
// includes(value) – возвращает true, если в массиве имеется элемент value, в противном случае false.
// find / filter(func) – фильтрует элементы через функцию и отдаёт первое / все значения, при прохождении которых через функцию возвращается true.
// findIndex похож на find, но возвращает индекс вместо значения.

// ?Для перебора элементов:

// forEach(func) – вызывает func для каждого элемента.Ничего не возвращает.

// ?Для преобразования массива:

// map(func) – создаёт новый массив из результатов вызова func для каждого элемента.
// sort(func) – сортирует массив «на месте», а потом возвращает его.
// reverse() – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.
// split / join – преобразует строку в массив и обратно.
// reduce / reduceRight(func, initial) – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.

// ?Дополнительно:

// Array.isArray(arr) проверяет, является ли arr массивом.
// Пожалуйста, обратите внимание, что методы push, pop, shift, unshift, sort, reverse и splice изменяют исходный массив.

// !Эти методы – самые используемые, их достаточно в 99 % случаев.Но существуют и другие:

// arr.some(fn) / arr.every(fn) проверяет массив.

// Функция fn вызывается для каждого элемента массива аналогично map.Если какие - либо / все результаты вызовов являются true, то метод возвращает true, иначе false.

// Эти методы ведут себя примерно так же, как операторы || и &&: если fn возвращает истинное значение, arr.some() немедленно возвращает true и останавливает перебор остальных элементов; если fn возвращает ложное значение, arr.every() немедленно возвращает false и также прекращает перебор остальных элементов.

// Мы можем использовать every для сравнения массивов:

// function arraysEqual(arr1, arr2) {
//   return arr1.length === arr2.length && arr1.every((value, index) => value === arr2[index]);
// }

// alert(arraysEqual([1, 2], [1, 2])); // true
// arr.fill(value, start, end) – заполняет массив повторяющимися value, начиная с индекса start до end.

// arr.copyWithin(target, start, end) – копирует свои элементы, начиная с позиции start и заканчивая end, в себя, на позицию target(перезаписывая существующие).

// arr.flat(depth) / arr.flatMap(fn) создаёт новый плоский массив из многомерного массива.

// Полный список есть в справочнике MDN.

// На первый взгляд может показаться, что существует очень много разных методов, которые довольно сложно запомнить.Но это гораздо проще, чем кажется.

// Внимательно изучите шпаргалку, представленную выше, а затем, чтобы попрактиковаться, решите задачи, предложенные в данной главе.Так вы получите необходимый опыт в правильном использовании методов массива.

// Всякий раз, когда вам будет необходимо что - то сделать с массивом, а вы не знаете, как это сделать – приходите сюда, смотрите на таблицу и ищите правильный метод.Примеры помогут вам всё сделать правильно, и вскоре вы быстро запомните методы без особых усилий.


// Напишите функцию shuffle(array), которая перемешивает(переупорядочивает случайным образом) элементы массива.
// Многократные прогоны через shuffle могут привести к разным последовательностям элементов.Например:
arr = [1, 2, 3]
function shuffle(arr: any[]) {
  const newArr = [] as any[]
  const indexArray = [] as number[]
  let i = 0
  do {
    const randInt = randomInteger(0, arr.length - 1)
    i++
    if (!indexArray.includes(randInt)) {
      indexArray.push(randInt)
      newArr.push(arr[randInt])
    }
  } while (indexArray.length != arr.length)
  console.log(i)
  return newArr
}

shuffle(arr)

// let count = {
//   '123': 0,
//   '132': 0,
//   '213': 0,
//   '231': 0,
//   '321': 0,
//   '312': 0
// } as any

// for (let i = 0; i < 1000000; i++) {
//   let array = [1, 2, 3]
//   const newArr = shuffle(array)
//   count[newArr.join('')]++
// }

// // показать количество всех возможных вариантов
// for (let key in count) {
//   console.log(`${key}: ${count[key]}`);
// }


//  Агрегирование данных: У вас есть массив объектов с числовыми значениями (например, продажами товаров за месяц). 
let arrayOfGoods = [
  {
    name: 'vans knew school',
    quantity: 1,
    price: 15600
  },
  {
    name: 'adidas campus',
    quantity: 1,
    price: 17400
  },
  {
    name: 'nike air trainer',
    quantity: 1,
    price: 22300
  },
] as any
// Найдите сумму, среднее и максимальное значение этих числовых данных.
function averagePrice(arrayOfGoods: any) {
  const agregate = {
    sum: 0,
    average: 0,
    max: 0
  }
  agregate.sum = arrayOfGoods.reduce((sum: number, el: any) => sum += el.quantity * el.price, 0)
  agregate.average = agregate.sum / arrayOfGoods.length
  agregate.max = Math.max(...arrayOfGoods.map((el: any) => el.quantity * el.price))
  return agregate
}
console.log(averagePrice(arrayOfGoods))

console.log('Object.keys(arrayOfGoods[0])')
for (let el of Object.keys(arrayOfGoods[0])) {
  console.log(el, arrayOfGoods[0][el])
}
console.log('Object.values(arrayOfGoods[0])')
for (let el of Object.values(arrayOfGoods[0])) {
  console.log(el)
}
console.log('Object.entries(arrayOfGoods[0])', Object.entries(arrayOfGoods[0]))
for (let el of Object.entries(arrayOfGoods[0])) {
  console.log(el, el[0], el[1])
}

// Трансформации объекта
// У объектов нет множества методов, которые есть в массивах, например map, filter и других.

// Если мы хотели бы их применить, то можно использовать Object.entries с последующим вызовом Object.fromEntries:

// Вызов Object.entries(obj) возвращает массив пар ключ / значение для obj.
// На нём вызываем методы массива, например, map.
// Используем Object.fromEntries(array) на результате, чтобы преобразовать его обратно в объект.
// Например, у нас есть объект с ценами, и мы хотели бы их удвоить:

let prices = {
  banana: 1,
  orange: 2,
  meat: 4,
};

let doublePrices = Object.fromEntries(
  // преобразовать в массив, затем map, затем fromEntries обратно объект
  Object.entries(prices).map(([key, value]) => [key, value * 2])
);

console.log(doublePrices.meat); // 8

// Деструктуризация массива
// Вот пример деструктуризации массива на переменные:

// у нас есть массив с именем и фамилией
arr = ["Ilya", "Kantor", "Kantor", "Kantor5", "Kantor"] as any

// деструктурирующее присваивание
// записывает firstName = arr[0]
// и surname = arr[1]
let [, , , surname1] = arr

console.log(surname1) // Kantor5

// Теперь мы можем использовать переменные вместо элементов массива.
// Отлично смотрится в сочетании со split или другими методами, возвращающими массив:

// !Если мы хотим не просто получить первые значения, но и собрать все остальные, то мы можем добавить ещё один параметр, который получает остальные значения, используя оператор «остаточные параметры» – троеточие("..."):
let [firstName2, surname2, ...rest] = "Ilya Kantor gdfgdeg sdfsd f".split(' ')
console.log(firstName2) // Ilya
console.log(surname2)  // Kantor
console.log(rest)  //остальные

// !Переменная rest является массивом из оставшихся элементов.

// !Вместо rest можно использовать любое другое название переменной, просто убедитесь, что перед переменной есть три точки и она стоит на последнем месте в деструктурирующем присваивании.

// Присваивайте чему угодно с левой стороны
// Мы можем использовать что угодно «присваивающее» с левой стороны.

// Например, можно присвоить свойству объекта:

user = {} as any
[user.name, user.surname] = "Ilya Kantor".split(' ');

console.log(user.name); // Ilya
console.log(user.surname); // Kantor

// !цикл по ключам и значениям с деструктуризацией
for (let [key, value] of Object.entries(user)) {
  console.log(`${key}:${value}`)
}

// Трюк обмена переменных
// Существует хорошо известный трюк для обмена значений двух переменных с использованием деструктурирующего присваивания:

let guest = "Jane"
let admin = "Pete"

  // Давайте поменяем местами значения: сделаем guest = "Pete", а admin = "Jane"
  ;[guest, admin] = [admin, guest]

console.log(`${guest} ${admin}`) // Pete Jane (успешно заменено!)
// Здесь мы создаём временный массив из двух переменных и немедленно деструктурируем его в порядке замены.
// Таким образом, мы можем поменять местами даже более двух переменных.

// !Если мы хотим, чтобы значение «по умолчанию» заменило отсутствующее, мы можем указать его с помощью =:

// значения по умолчанию
let [name1 = "Guest", surname = "Anonymous"] = ["Julius"];

console.log(name1);    // Julius (из массива)
console.log(surname); // Anonymous (значение по умолчанию)
// !Значения по умолчанию могут быть гораздо более сложными выражениями или даже функциями.Они выполняются, только если значения отсутствую





// !Итого
// ?Деструктуризация позволяет разбивать объект или массив на переменные при присвоении.

// ?Полный синтаксис для объекта:

// let { prop: varName = default, ...rest } = object

// Cвойство prop объекта object здесь должно быть присвоено переменной varName.Если в объекте отсутствует такое свойство, переменной varName присваивается значение по умолчанию.

// Свойства, которые не были упомянуты, копируются в объект rest.

// ?Полный синтаксис для массива:

// let [item1 = default , item2, ...rest] = array
// Первый элемент отправляется в item1; второй отправляется в item2, все остальные элементы попадают в массив rest.

// Можно извлекать данные из вложенных объектов и массивов, для этого левая сторона должна иметь ту же структуру, что и правая.


// !Написать функцию, которая проверяет, является ли пере-
// данная строка палиндромом.

function polindom(str: string) {
  const i = Math.floor(str.length / 2)
  if (str.length % 2) {
    return str.slice(0, i) == str.slice(i + 1).split('').reverse().join('')
  }
  return str.slice(0, i) == str.slice(i).split('').reverse().join('')
}

console.log(polindom('1234321'))
console.log(polindom('1234320'))
console.log(polindom('123321'))
console.log(polindom('123320'))

function sum1(a: number, b: number, ...rest: number[]) {
  return a + b + rest.reduce((sum, el) => sum + el)
}
function sum2(...остальные: number[]) {
  return остальные.reduce((sum, el) => sum + el)
}

console.log(sum1(1, 2, 3, 4, 5))
console.log(sum2(...[1, 2, 3, 4, 5]))

const arrCopy = [...arr]
console.log(arrCopy)
const objCopy = { ...arr }
console.log(objCopy)

  ; (function mergeArr() {
    let arr = [3, 5, 1]
    let arr2 = [8, 9, 15]
    let merged = [0, ...arr, 2, ...arr2].sort((a, b) => a - b)
    console.log(merged)
  })()

// !Array.from преобразует перебираемый объект в массив
// ?между Array.from(obj) и[...obj] есть разница:

// Array.from работает как с псевдомассивами, так и с итерируемыми объектами
// Оператор расширения работает только с итерируемыми объектами
// Выходит, что если нужно сделать из чего угодно массив, то Array.from — более универсальный метод.

// Итого
// Когда мы видим "..." в коде, это могут быть как остаточные параметры (REST), так и оператор расширения (SPREAD)

// Как отличить их друг от друга:

// Если ... располагается в конце списка параметров функции, то это «остаточные параметры». Он собирает остальные неуказанные аргументы и делает из них массив.
// Если ... встретился в вызове функции или где - либо ещё, то это «оператор расширения». Он извлекает элементы из массива.
// Полезно запомнить:

// Остаточные параметры используются, чтобы создавать новые функции с неопределённым числом аргументов.
// С помощью оператора расширения можно вставить массив в функцию, которая по умолчанию работает с обычным списком аргументов.
// Вместе эти конструкции помогают легко преобразовывать наборы значений в массивы и обратно

// @ts-ignore
console.log(varVar)
var varVar = 10
console.log(varVar)
var varVar = 20
console.log(varVar)


// С помощью блоков {... } мы можем изолировать часть кода, выполняющую свою собственную задачу, с переменными, принадлежащими только ей:

{
  // показать сообщение
  let message = "Hello"
  console.log(message)
}

{
  // показать другое сообщение
  let message = "Goodbye"
  console.log(message)
}

console.log(message)

// Для if, for, while и т.д.переменные, объявленные в блоке кода {... }, также видны только внутри:

if (true) {
  let phrase = "Hello";
  console.log(phrase); // Hello
}

// alert(phrase); // Ошибка, нет такой переменной!

// !И это замечательно, поскольку это позволяет нам создавать блочно-локальные переменные, относящиеся только данному блоку кода

// !!!Вложенные функции

function makeCounter(count: number) {
  const countersDiv = document.getElementById('counters')
  const button = document.createElement('button')
  button.textContent = count.toFixed()
  button.onclick = function () {
    button.textContent = (++count).toFixed()
  }
  countersDiv?.append(button)
}

makeCounter(0)
makeCounter(5)
makeCounter(10)


// !Замыкания
// В программировании есть общий термин: «замыкание», – который должен знать каждый разработчик.

// Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ.В некоторых языках это невозможно, или функция должна быть написана специальным образом, чтобы получилось замыкание.Но, как было описано выше, в JavaScript, все функции изначально являются замыканиями(есть только одно исключение, про которое будет рассказано в Синтаксис "new Function").

// То есть они автоматически запоминают, где были созданы, с помощью скрытого свойства[[Environment]], и все они могут получить доступ к внешним переменным.

// !Когда на собеседовании фронтенд - разработчику задают вопрос: «что такое замыкание ?», – правильным ответом будет определение замыкания и объяснения того факта, что все функции в JavaScript являются замыканиями, и, может быть, несколько слов о технических деталях: свойстве[[Environment]] и о том, как работает лексическое окружение.

// Сумма с помощью замыканий
// важность: 4
// Напишите функцию sum, которая работает таким образом: sum(a)(b) = a + b.

// Да, именно таким образом, используя двойные круглые скобки(не опечатка).

// Например:

function closureSum(a: number) {
  return function (b: number) {
    return a + b
  }
}

console.log(closureSum(1)(2))
console.log(closureSum(5)(-1))

// Каррирование
const operand4 = closureSum(4)
console.log(operand4(-2))
console.log(operand4(2))
console.log(operand4(12))

// Функция - конструктор
// Функции - конструкторы технически являются обычными функциями.Но есть два соглашения:

// Имя функции - конструктора должно начинаться с большой буквы.
// Функция - конструктор должна выполняться только с помощью оператора "new".

// this это {} (пустой объект)
const User = (function (this: Record<string, any>, name: string) {
  // во время создания нового объекта при помощи оператора new, в this присваивается пустой объект
  // this = {};  (неявно)

  // выполняется тело функции.Обычно оно модифицирует this, добавляя туда новые свойства
  // добавляет свойства к this
  this.name = name
  this.isAdmin = false
  this.isLogin = function () {
    return false
  }
  // неявно возвращается this
  // return this (неявно)
}) as any

// Функция-конструктор, создающая объект с переданным именеи и ложью в свойстве isAdmin
const SimpleUser = (function (this: Record<string, any>, name: string) {
  this.name = name
  this.isAdmin = false
  this.isLogin = function () {
    return false
  }
}) as any

const simpleUser = function (name: string) {
  return {
    name,
    isAdmin: false,
    isLogin() {
      return false
    }
  }
}

console.log(new SimpleUser('Student'))
console.log((new SimpleUser('Student')).isLogin == (new SimpleUser('Student1')).isLogin)
console.log(simpleUser('Student'))
console.log(simpleUser('Student').isLogin == simpleUser('Student1').isLogin)

class NewUser {
  name
  isAdmin
  constructor(name: string) {
    // во время создания нового объекта при помощи оператора new, в this присваивается пустой объект
    // this = {};  (неявно)
    this.name = name
    this.isAdmin = false
  }
  isLogin() {
    return false
  }
}

// Таким образом, let user = new User("Jack") возвращает тот же результат, что и:

// let user = {
//   name: "Jack",
//   isAdmin: false
// }

console.log({ name: 'noJack1', admin: true, isLogin() { return false } })
console.log((new User('Jack')))
console.log((new User('Jack')).constructor.name)
console.log(new NewUser('Pirat'))
console.log(new NewUser('Pirat').constructor.name)
console.log((new NewUser('Pirat')).isAdmin == (new NewUser('Pirat2')).isAdmin)
console.log(new NewUser('Pirat2'))
console.log(Object.keys(simpleUser('Jack0')))
console.log(Object.keys(new User('Jack')))
console.log(Object.keys(new NewUser('Pirat')))


// Используя специальное свойство new.target внутри функции, мы можем проверить, вызвана ли функция при помощи оператора new или без него.

// В случае обычного вызова функции new.target будет undefined.Если же она была вызвана при помощи new, new.target будет равен самой функции.
const User1 = (function (this: any, name: string) {
  console.log(new.target)
  if (!new.target) { // в случае, если вы вызвали меня без оператора new
    return new User1(name) // ...я добавлю new за вас
  }
  this.name = name
}) as any

let john = User1("John") // переадресовывает вызов на new User
let john1 = new User1("John") // переадресовывает вызов на new User
console.log(john.name) // John

// !Возврат значения из конструктора, return
// Обычно конструкторы не имеют оператора return.Их задача – записать все необходимое в this, и это автоматически становится результатом.

// Но если return всё же есть, то применяется простое правило:

// При вызове return с объектом, вместо this вернётся объект.
// При вызове return с примитивным значением, оно проигнорируется.
// Другими словами, return с объектом возвращает этот объект, во всех остальных случаях возвращается this.

// Функции-конструкторы или просто конструкторы, являются обычными функциями, но существует общепринятое соглашение именовать их с заглавной буквы.
// Функции-конструкторы следует вызывать только с помощью new. Такой вызов подразумевает создание пустого this в начале и возврат заполненного в конце.
// Мы можем использовать конструкторы для создания множества похожих объектов.

console.log(new Date())

// Геттеры (получатели) и сеттеры (устанавливатели) - методы объекта, ведущие себя как свойства

const car = {
  name: 'tio',
  _fuel: 10,
  getFuel() {
    return this._fuel
  },
  // геттер всегда что-то возвращает
  get fuel() {
    return this._fuel
  },
  setFuel(val: number) {
    this._fuel += val
  },
  // сеттер всегда что-то устанавливает
  set refuel(val: number) {
    this._fuel += val
  },
  get refuel() {
    return this._fuel
  }
}

console.log(car.getFuel())
car.setFuel(10)
console.log(car.fuel) // сработал геттер
car.refuel = 20 // сработал сеттер
console.log(car.fuel)

const student = {
  name: 'Asd',
  surname: 'Daf',
  get fullname() {
    return `${this.name} ${this.surname}`
  },
  set fullname(fio: string) {
    ;[this.name, this.surname] = fio.split(' ')
  },
  toString() {
    return `I'm student ${this.fullname}`
  }
}

console.log(student)
console.log(student.fullname)
student.fullname = 'fsda sgflkj ывфвв'
console.log(student.fullname)
console.log(student)
console.log(student.toString())

// В объектно-ориентированном программировании класс – это расширяемый шаблон кода для создания объектов, который устанавливает в них начальные значения (свойства) и реализацию поведения (методы).

// В JavaScript класс – это разновидность функции.

//  Взгляните:

// class User {
//   constructor(name) { this.name = name; }
//   sayHi() { alert(this.name); }
// }

// доказательство: User - это функция
// alert(typeof User); // function
// Вот что на самом деле делает конструкция class User {... }:

// Создаёт функцию с именем User, которая становится результатом объявления класса.Код функции берётся из метода constructor(она будет пустой, если такого метода нет).
// Сохраняет все методы, такие как sayHi, в User.prototype.
// При вызове метода объекта new User он будет взят из прототипа, как описано в главе F.prototype.Таким образом, объекты new User имеют доступ к методам класса.

// класс - это функция
console.log(typeof NewUser); // function

// ...или, если точнее, это метод constructor
console.log(NewUser === NewUser.prototype.constructor); // true

// Методы находятся в User.prototype, например:
console.log(NewUser.prototype.isLogin); // sayHi() { alert(this.name); }

// в прототипе ровно 2 метода
console.log(Object.getOwnPropertyNames(NewUser.prototype)); // constructor, sayHi

// Базовый синтаксис для классов выглядит так:

// class MyClass {
//   prop = value; // свойство
//   constructor(...) { // конструктор
//     // ...
//   }
//   method(...) { } // метод
//   get something(...) { } // геттер
//   set something(...) { } // сеттер
//   [Symbol.iterator]() { } // метод с вычисляемым именем (здесь - символом)
//   // ...
// }
// MyClass технически является функцией(той, которую мы определяем как constructor), в то время как методы, геттеры и сеттеры записываются в MyClass.prototype.

// Реализовать класс, описывающий html элемент.
// Класс HtmlElement должен содержать внутри себя:
// ■ название тега;
// ■ самозакрывающийся тег или нет;
// ■ текстовое содержимое;
// ■ массив атрибутов;
// ■ массив стилей;
// ■ массив вложенных таких же тегов;
// метод для установки атрибута;
// ■ метод для установки стиля;
// ■ метод для добавления вложенного элемента в конец текущего элемента;
// ■ метод для добавления вложенного элемента в начало текущего элемента;
// ■ метод getHtml(), который возвращает html код в виде
// строки, включая html код вложенных элементов.
// С помощью написанного класса реализовать следующий блок
// и добавить его на страницу с помощью document.write().

class HtmlElement {
  tag: string
  paired: boolean
  text: string
  attrs: string[] = []
  styles: string[] = []
  htmlElements: HtmlElement[] = []
  constructor(tag: string, paired: boolean, text: string) {
    this.tag = tag
    this.paired = paired
    this.text = text
  }
  setAttr(name: string, value: string) {
    this.attrs.push(`${name}="${value}"`)
  }
  setStyle(name: string, value: string) {
    this.styles.push(`${name}:${value}`)
  }
  append(element: HtmlElement) {
    this.htmlElements.push(element)
  }
  prepend(element: HtmlElement) {
    this.htmlElements.unshift(element)
  }
  getHtml(): string {
    if (this.styles.length) {
      this.setAttr('style', this.styles.join(';'))
    }
    if (this.paired) {
      return `<${this.tag} ${this.attrs.join(' ')}>${this.text}
${this.htmlElements.map(el => el.getHtml()).join('')} 
</${this.tag}>`
    } else {
      return `<${this.tag} ${this.attrs.join(' ')}>`
    }
  }
}

const wrapper = new HtmlElement('div', true, '')
wrapper.setAttr('id', 'wrapper')
wrapper.setStyle('display', 'flex')
const innerDiv = new HtmlElement('div', true, '')
innerDiv.setStyle('width', '300px')
innerDiv.setStyle('margin', '10px')
const h3 = new HtmlElement('h3', true, 'What is Lorem Ipsum?')
const img = new HtmlElement('img', false, '')
img.setAttr('src', 'cvety-cvetok-buket-priroda.jpg')
img.setAttr('alt', 'Lorem Ipsum')
img.setStyle('width', '100%')
const p = new HtmlElement('p', true, 'Lorem, ipsum dolor sit amet consectetur adipisicing elit. Alias harum fuga magni quasi ex pariatur reprehenderit laudantium esse. Veritatis maiores qui fugiat nostrum, quo nihil sit recusandae aspernatur incidunt dolore.')
p.setStyle('text-align', 'justify')
const href = new HtmlElement('a', true, 'More...')
href.setAttr('href', 'https://www.lipsum.com/')
href.setAttr('target', '_blank')

p.append(href)
innerDiv.append(h3)
innerDiv.append(img)
innerDiv.append(p)
wrapper.append(innerDiv)
wrapper.append(innerDiv)
const iframe = document.querySelector('iframe')

// <script src="https://rawgit.com/Microsoft/TypeScript/master/lib/typescriptServices.js"></script>
// <script src="https://rawgit.com/basarat/typescript-script/master/transpiler.js"></script>
// <script type="text/typescript">
// const target = e.target as HTMLElement
const script = `
<script>
document.addEventListener('click', (e)=>{
  if (e.target.tagName == 'A') {
    alert('Попытка перехода на другой сайт')
    e.target.target = '_self'
  }
  return
})
</script>
`
// https://habr.com/ru/articles/488516/
if (iframe) iframe.srcdoc = '<!DOCTYPE><html><body>' + wrapper.getHtml() + script + '</body></html>'

// Объект Date
// !Дата и время в JavaScript представлены объектом Date.Нельзя создать «только дату» или «только время»: объекты Date всегда содержат и то, и другое.
// !Счёт месяцев начинается с нуля(да, январь – это нулевой месяц).
// !Дни недели в getDay() также отсчитываются с нуля, что соответствует воскресенью.
// ?Объект Date самостоятельно корректируется при введении значений, выходящих за рамки допустимых.Это полезно для сложения / вычитания дней / месяцев / недель.
// ?Даты можно вычитать, и разность возвращается в миллисекундах.Так происходит, потому что при преобразовании в число объект Date становится таймстампом.
// !Используйте Date.now() для быстрого получения текущего времени в формате таймстампа.
// !Учтите, что, в отличие от некоторых других систем, в JavaScript таймстамп в миллисекундах, а не в секундах.

// Unix time, он же timestamp, он же метка времени
console.log('Кол-во миллисекунд, прошедшее с 01.01.1970 00:00 (Unix time)', Date.now())
console.log('Текуее время', new Date())
console.log('Создание времени из метки', new Date(Date.now()))
console.log('Создание времени из строки', new Date('2023-10-16'))
console.log('Создание времени из строки', new Date('2023-10-16T19:47:00'))

// Прототипное наследование


let animal = {
  eats: true,
  walk() {
    console.log("Animal walk");
  }
} as any

let rabbit = {
  jumps: true
} as any
rabbit.__proto__ = animal

rabbit.walk = function () {
  console.log("Rabbit! Bounce-bounce!")
}

let longEar = {
  earLength: 10,
  __proto__: rabbit
} as any

// animal.__proto__ = longEar

// walk взят из цепочки прототипов
longEar.walk() // Animal walk
console.log(longEar.jumps) // true (из rabbit)
// Object.keys возвращает только собственные ключи
console.log(Object.keys(longEar)) // earLength


console.log(longEar.__proto__) //rabbit
console.log(longEar.__proto__.__proto__) //animal
console.log(longEar.__proto__.__proto__.__proto__) //Object
console.log(longEar.__proto__.__proto__.__proto__.__proto__) //null (undefined)



// for..in проходит и по своим, и по унаследованным ключам
for (let prop in longEar) {
  let isOwn = longEar.hasOwnProperty(prop);

  if (isOwn) {
    console.log(`Our: ${prop}`); // Our: jumps
  } else {
    console.log(`Inherited: ${prop}`); // Inherited: eats
  }
}

console.log(rabbit)
console.log('rabbit.eats', rabbit.eats)
rabbit.walk()

let user3 = {
  name: "John",
  surname: "Smith",

  set fullName(value) {
    [this.name, this.surname] = value.split(" ");
  },

  get fullName() {
    return `${this.name} ${this.surname}`;
  }
};

let admin3 = {
  __proto__: user3,
  isAdmin: true
} as any

console.log(admin3)
console.log(admin3.fullName); // John Smith (*)

// Значение «this»
// Прототипы никак не влияют на this.
// Неважно, где находится метод: в объекте или его прототипе. При вызове метода this — всегда объект перед точкой.

// срабатывает сеттер!
admin3.fullName = "Alice Cooper"; // (**)
console.log(admin3.name); // Alice
console.log(admin3.surname); // Cooper
console.log(admin3)

// В JavaScript все объекты имеют скрытое свойство[[Prototype]], которое является либо другим объектом, либо null.
// Мы можем использовать obj.__proto__ для доступа к нему(исторически обусловленный геттер / сеттер, есть другие способы, которые скоро будут рассмотрены).
// Объект, на который ссылается[[Prototype]], называется «прототипом».
// Если мы хотим прочитать свойство obj или вызвать метод, которого не существует у obj, тогда JavaScript попытается найти его в прототипе.
// Операции записи / удаления работают непосредственно с объектом, они не используют прототип(если это обычное свойство, а не сеттер).
// Если мы вызываем obj.method(), а метод при этом взят из прототипа, то this всё равно ссылается на obj.Таким образом, методы всегда работают с текущим объектом, даже если они наследуются.
// Цикл for..in перебирает как свои, так и унаследованные свойства.Остальные методы получения ключей / значений работают только с собственными свойствами объекта.

{
  let animal = {
    eats: true
  }
  let superAnimal = {
    eats: false,
  }

  const Rabbit = (function (this: any, name: string) {
    this.name = name
  }) as any

  console.log(Rabbit.prototype.constructor == Rabbit)
  /* прототип по умолчанию
  Rabbit.prototype = { constructor: Rabbit };
  */

  // Rabbit.prototype = animal
  Rabbit.prototype = { ...animal, constructor: Rabbit }
  let rabbit = new Rabbit("White Rabbit") //  rabbit.__proto__ == animal
  console.log(rabbit)
  console.log(new rabbit.constructor('Yellow Rabbit'))


  Rabbit.prototype = superAnimal
  let rabbit2 = new Rabbit("Black Rabbit") //  rabbit.__proto__ == superAnimal
  console.log(rabbit2)

  // В этой главе мы кратко описали способ задания [[Prototype]] для объектов, создаваемых с помощью функции-конструктора. Позже мы рассмотрим, как можно использовать эту возможность.

  // Всё достаточно просто. Выделим основные моменты:

  // Свойство F.prototype (не путать с [[Prototype]]) устанавливает[[Prototype]] для новых объектов при вызове new F().
  // Значение F.prototype должно быть либо объектом, либо null. Другие значения не будут работать.
  // Свойство "prototype" является особым, только когда оно назначено функции-конструктору, которая вызывается оператором new.
  // В обычных объектах prototype не является чем-то особенным:

  // let user = {
  //   name: "John",
  //   prototype: "Bla-bla" // никакой магии нет - обычное свойство
  // };
  // По умолчанию все функции имеют F.prototype = { constructor: F }, поэтому мы можем получить конструктор объекта через свойство "constructor".

}


{
  // Встроенные прототипы
  // console.log(Object.prototype.__proto__) // null

  let arr = [1, 2, 3] as any

  // наследует ли от Array.prototype?
  console.log(arr.__proto__ === Array.prototype); // true

  // затем наследует ли от Object.prototype?
  console.log(arr.__proto__.__proto__ === Object.prototype); // true

  // и null на вершине иерархии
  console.log(arr.__proto__.__proto__.__proto__); // null
  console.dir(arr)

  // String.prototype.show = function () {
  //   console.log(this, this, this)
  // }

  // "BOOM!".show(); // BOOM! BOOM! BOOM!

  let obj = {
    0: "Hello",
    1: "world!",
    length: 2,
  } as any

  obj.__proto__ = Array.prototype
  obj.push(`I'm like Array`)
  console.log(obj)
  console.log(obj.join(',')) // Hello,world!
}

{
  let animal = {
    eats: true
  };

  // создаём новый объект с прототипом animal
  let rabbit = Object.create(animal)

  let rabbit2 = {
    name: 'bunny',
    jumps: true
  } as any
  Object.setPrototypeOf(rabbit2, animal)

  console.log(rabbit.eats) // true
  console.log(rabbit2.eats) // true

  console.log(Object.getPrototypeOf(rabbit) === animal) // получаем прототип объекта rabbit

  Object.setPrototypeOf(rabbit, {}) // заменяем прототип объекта rabbit на {}

  let rabbit3 = Object.create(animal, {
    jumps: {
      writable: true, // определяет, можно ли изменять значение свойства
      enumerable: true, // определяет, будет ли свойство выводиться в циклах и Object.keys, values, entries
      configurable: true, // определяет, можно ли менять все эти свойства 
      value: true
    }
  });

  console.log(rabbit3.jumps) // true
  // rabbit3.jumps = false
  // console.log(rabbit3.jumps)

  for (let prop in rabbit3) {
    console.log(prop)
  }

  // Современные способы установки и прямого доступа к прототипу это:

  // Object.create(proto[, descriptors]) – создаёт пустой объект со свойством [[Prototype]], указанным как proto (может быть null), и необязательными дескрипторами свойств.
  // Object.getPrototypeOf(obj) – возвращает свойство [[Prototype]] объекта obj (то же самое, что и геттер __proto__).
  // Object.setPrototypeOf(obj, proto) – устанавливает свойство [[Prototype]] объекта obj как proto (то же самое, что и сеттер __proto__).
  // Встроенный геттер/сеттер __proto__ не безопасен, если мы хотим использовать созданные пользователями ключи в объекте. Как минимум потому, что пользователь может ввести "__proto__" как ключ, от чего может возникнуть ошибка. Если повезёт – последствия будут лёгкими, но, вообще говоря, они непредсказуемы.

  // Так что мы можем использовать либо Object.create(null) для создания «простейшего» объекта, либо использовать коллекцию Map.

  // Кроме этого, Object.create даёт нам лёгкий способ создать поверхностную копию объекта со всеми дескрипторами:

  // let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
  // Мы также ясно увидели, что __proto__ – это геттер/сеттер для свойства [[Prototype]], и находится он в Object.prototype, как и другие методы.

  // Мы можем создавать объекты без прототипов с помощью Object.create(null). Такие объекты можно использовать как «чистые словари», у них нет проблем с использованием строки "__proto__" в качестве ключа.

  // Ещё методы:

  // Object.keys(obj) / Object.values(obj) / Object.entries(obj) – возвращают массив всех перечисляемых собственных строковых ключей/значений/пар ключ-значение.
  // Object.getOwnPropertySymbols(obj) – возвращает массив всех собственных символьных ключей.
  // Object.getOwnPropertyNames(obj) – возвращает массив всех собственных строковых ключей.
  // Reflect.ownKeys(obj) – возвращает массив всех собственных ключей.
  // obj.hasOwnProperty(key): возвращает true, если у obj есть собственное (не унаследованное) свойство с именем key.
  // Все методы, которые возвращают свойства объектов (такие как Object.keys и другие), возвращают «собственные» свойства. Если мы хотим получить и унаследованные, можно воспользоваться циклом for..in.
}

{
  // !Наслкдование классов

  class Animal {
    name
    speed
    constructor(name: string) {
      this.speed = 0
      this.name = name
    }
    run(speed: number) {
      this.speed = speed
      console.log(`${this.name} бежит со скоростью ${this.speed}.`)
    }
    stop() {
      this.speed = 0
      console.log(`${this.name} стоит неподвижно.`)
    }
  }

  let animal = new Animal("Мой питомец")

  // У классов есть ключевое слово "super" для таких случаев.

  // super.method(...) вызывает родительский метод.
  // super(...) для вызова родительского конструктора(работает только внутри нашего конструктора).
  // У стрелочных функций нет super и this
  class Rabbit extends Animal {
    // неявно генерируется для классов-потомков, у которых нет своего конструктора
    // constructor(...args) {
    //   super(...args);
    // }
    earLength
    constructor(name:string, earLength:number) {
      super(name)
      this.earLength = earLength
    }

    hide() {
      console.log(`${this.name} прячется!`)
    }
    stop() {
      super.stop() // вызываем родительский метод stop
      this.hide() // и затем hide
    }
    stopAfterDelay(seconds:number) {
      setTimeout(() => this.stop(), seconds*1000); // вызывает родительский stop после 1 секунды
    }
  }

  let rabbit = new Rabbit("Белый кролик",10)

  console.log(rabbit)
  console.log(rabbit.name)
  console.log(rabbit.speed)
  rabbit.run(5) // Белый кролик бежит со скоростью 5.
  rabbit.stopAfterDelay(3) // Белый кролик прячется!
  console.log(rabbit.speed)

//   Методы, а не свойства-функции
// Свойство [[HomeObject]] определено для методов как классов, так и обычных объектов. Но для объектов методы должны быть объявлены именно как method(), а не "method: function()".

}

const timerDiv = document.querySelector('#timer p') as HTMLParagraphElement

class Clock {
  template
  timer = 0
  constructor({ template }: any) {
    this.template = template
  }
  render() {
    const date = new Date()
    const hours = date.getHours()
    const h = hours < 10 ? '0' + hours : hours

    const mins = date.getMinutes()
    const m = mins < 10 ? '0' + mins : mins

    const secs = date.getSeconds()
    const s = secs < 10 ? '0' + secs : secs

    let output = this.template
      .replace('h', h)
      .replace('m', m)
      .replace('s', s)

    timerDiv.textContent = output
  }

  stop() {
    clearInterval(this.timer)
  }

  start() {
    this.render()
    this.timer = setInterval(() => this.render(), 1000)
  }

}

class ExtendedClock extends Clock {
  precision
  constructor(template: any, precision=1000) {
    super(template)
    this.precision = precision
  }
  start() {
    this.render()
    this.timer = setInterval(() => this.render(), this.precision)
  }
}

// Создайте новый класс ExtendedClock, который будет наследоваться от Clock и добавьте параметр precision – количество миллисекунд между «тиками». Установите значение в 1000(1 секунда) по умолчанию

let clock = new ExtendedClock({ template: 'h:m:s' })
const timerButtons = document.querySelectorAll('#timer button') as NodeListOf<HTMLButtonElement>
timerButtons[0].addEventListener('click', () => clock.start())
timerButtons[1].addEventListener('click', () => clock.stop())

{
  class User {
    static race = 'human'
    static population = 0
    constructor() {
      User.population ++
    }
    static staticMethod() {
      console.log(this === User)
    }
  }

  User.staticMethod = function () {
    console.log(this === User)
  }
  
  const humans = [
    new User,
    (new User),
    (new User),
    (new User),
    (new User),
    (new User),
    (new User),
    (new User)
  ]
  console.log('population', User.population)

  class Article {
    static publisher = "Илья Кантор"
  }

  console.log( Article.publisher ) // Илья Кантор
  // Это то же самое, что и прямое присваивание Article:
  Article.publisher = "Илья Кантор"

}

class Bank {
  id
  cash
  static uid = 10
  static cash = 100000
  static clints = {} as Record<string, Bank>
  constructor(cash:number) {
    this.id = Bank.uid++
    if (cash>0) {
      this.cash = cash
    } else {
      this.cash = -cash
    }
    Bank.cash += cash
    Bank.clints[this.id] = this
  }
}

new Bank(1000)
console.log(Bank.cash)
new Bank(-10000)
console.log(Bank.cash)
new Bank(-40000)
console.log(Bank.cash)
new Bank(400000)

console.log(Bank.clints)
console.log(Bank.cash)

// You are given an integer array arr. Sort the integers in the array in ascending order by the number of 1's in their binary representation and in case of two or more integers have the same number of 1's you have to sort them in ascending order.
// Return the array after sorting it.

{
  const arr = [1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1]
  arr.sort((a, b) => {
    let A = a.toString(2).match(/1/g)?.length || 0
    let B = b.toString(2).match(/1/g)?.length || 0
    return A == B ? a - b : A - B
  })
  console.log(arr)
  console.log([1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024])
  console.log([1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024].map(el=>el.toString(2)))
  const arr2 = [0, 1, 2, 3, 4, 5, 6, 7, 8]
  arr2.sort((a, b) => {
    let A = a.toString(2).match(/1/g)?.length || 0
    let B = b.toString(2).match(/1/g)?.length || 0
    return A == B ? a - b : A - B
  })
  console.log(arr2.map(el=>el.toString(2)))
  console.log(['0', '1', '10', '100', '1000', '11', '101', '110', '111'])
  console.log([0, 1, 2, 4, 8, 3, 5, 6, 7])
  // [0, 1, 2, 3, 4, 5, 6, 7, 8]
  // ['0', '1', '10', '11', '100', '101', '110', '111', '1000']
  // [0, 1, 2, 4, 8, 3, 5, 6, 7]
  // ['0', '1', '10', '100', '1000', '11', '101', '110', '111']
}


// Example 1:
// Input: arr = [0,1,2,3,4,5,6,7,8]
// Output: [0,1,2,4,8,3,5,6,7]
// Explantion: [0] is the only integer with 0 bits.
// [1,2,4,8] all have 1 bit.
// [3,5,6] have 2 bits.
// [7] has 3 bits.
// The sorted array by bits is [0,1,2,4,8,3,5,6,7]
// Example 2:
// Input: arr = [1024,512,256,128,64,32,16,8,4,2,1]
// Output: [1,2,4,8,16,32,64,128,256,512,1024]
// Explantion: All integers have 1 bit in the binary representation, you should just sort them in ascending order.

// Реализуйте класс ExtendedDate, унаследовав его от стандарт -
//   ного класса Date и добавив следующие возможности:
// ■ метод для вывода даты(числа и месяца) текстом;
// ■ метод для проверки – это прошедшая дата или будущая
//   (если прошедшая, то метод возвращает false; если буду -
//   щая или текущая, то true);
// ■ метод для проверки – високосный год или нет;
// ■ метод, возвращающий следующую дату.
// Создайте объект класса ExtendedDate и выведите на экран
// результаты работы новых методов.

function numberToText(n: number) {
  if (n < -99 || n > 99) return 'Неверное число'
  let minusStr = ''
  let sN = ''
  const numberWithMinus = n.toString()
  if (numberWithMinus[0] == '-') {
    minusStr = 'минус '
    sN = numberWithMinus.slice(1)
  } else {
    sN = n.toString()
  }
  const oneNumber = [, 'первое', 'второе', 'третье', 'четвёртое', 'пятое', 'шестое', 'седьмое', 'восьмое', 'девятое']
  const secondOfTen = ['десятое', 'одиннадцатое', 'двенадцатое', 'тринадцатое', 'четырнадцатое', 'пятьнадцатое', 'шестьнадцатое', 'семьнадцатое', 'восемьнадцатое', 'девятьнадцатое']
  const firstOfMoreTen = [, , 'двадцать', 'тридцать', 'сорок', 'пятьдесят', 'шестьдесят', 'семьдесят', 'восемьдесят', 'девяносто']
  const firstOfMoreTenRound = [, , 'двадцатое', 'тридцатое', 'сорок', 'пятьдесят', 'шестьдесят', 'семьдесят', 'восемьдесят', 'девяносто']
  if (sN.length == 1) {
    return minusStr + oneNumber[+sN[0]]
  }
  if (sN.length == 2) {
    if (sN[0] == '1') {
      return minusStr + secondOfTen[+sN[1]]
    }
    if (sN[1] == '0') {
      return minusStr + firstOfMoreTenRound[+sN[0]]
    }
    return minusStr + firstOfMoreTen[+sN[0]] + ' ' + oneNumber[+sN[1]]
  }
}

class ExtendedDate extends Date {
  getRussianDate() {
    const month = ['января', 'февряля', 'марта', 'апреля', 'мая', 'июня', 'июля', 'августа', 'сентября', 'октября', 'ноября', 'декабря']
    return numberToText(this.getDate()) + ' ' + month[this.getMonth()]
  }
  isFuture() {
    return this.getTime() > Date.now()
  }
  isLeap() {
    const year = this.getFullYear()
    return year%4==0 && (year%100!=0 || year%400==0)
  }
  nextDate() {
    return new ExtendedDate(this.setDate(this.getDate()+1))
  }
}

console.log(new Date('10-02-2023'))
console.log(new ExtendedDate('10-02-2023'))
console.log(ExtendedDate.now())
console.log(new ExtendedDate(Date.now()-24*3600*1000).getRussianDate())
console.log(new ExtendedDate(Date.now()-24*3600*1000).isFuture())
console.log(new ExtendedDate().isFuture())
console.log(new ExtendedDate(Date.now() + 24 * 3600 * 1000).isFuture())
console.log(new ExtendedDate().isLeap())
console.log(new ExtendedDate('10-02-2024').isLeap())
console.log(new ExtendedDate('10-02-2300').isLeap())
console.log(new ExtendedDate('10-02-2400').isLeap())
console.log(new ExtendedDate().nextDate().nextDate().nextDate())

console.log(closureSum(3)(5))
console.log(a)
console.log((null+'a').split('ll').join('tell'))

const digitsDiv = document.querySelector('.digits') as HTMLDivElement
const inputDiv = document.querySelector('div.input') as HTMLDivElement

let pass = ''
digitsDiv.addEventListener('click', (e)=>{
  const target = e.target as HTMLElement
  if (target.tagName=='BUTTON') {
    if (target.dataset.val) pass += target.dataset.val
    if (target.dataset.action) pass = pass.slice(0, pass.length-1)
    inputDiv.textContent = '*'.repeat(pass.length)
    console.log(pass)
  }
})

// В терминах ООП отделение внутреннего интерфейса от внешнего называется инкапсуляция.

// Это даёт следующие выгоды:

// !Защита для пользователей, чтобы они не выстрелили себе в ногу
// ?Поддерживаемость
// Ситуация в программировании сложнее, чем с реальной кофеваркой, потому что мы не просто покупаем её один раз.Код постоянно подвергается разработке и улучшению.
// Если мы чётко отделим внутренний интерфейс, то разработчик класса сможет свободно менять его внутренние свойства и методы, даже не информируя пользователей…
// Если вы разработчик такого класса, то приятно знать, что приватные методы можно безопасно переименовывать, их параметры можно изменять и даже удалять, потому что от них не зависит никакой внешний код.
// В новой версии вы можете полностью всё переписать, но пользователю будет легко обновиться, если внешний интерфейс остался такой же.

// ?Сокрытие сложности
// Люди обожают использовать простые вещи.По крайней мере, снаружи.Что внутри – это другое дело.
// Программисты не являются исключением.
// Всегда удобно, когда детали реализации скрыты, и доступен простой, хорошо документированный внешний интерфейс.
// Для сокрытия внутреннего интерфейса мы используем защищённые или приватные свойства:

// !Защищённые поля имеют префикс _.Это хорошо известное соглашение, не поддерживаемое на уровне языка.Программисты должны обращаться к полю, начинающемуся с _, только из его класса и классов, унаследованных от него.
// !Приватные поля имеют префикс #.JavaScript гарантирует, что мы можем получить доступ к таким полям только внутри класса.
// В настоящее время приватные поля не очень хорошо поддерживаются в браузерах, но можно использовать полифил.

{
  class PowerArray extends Array {
    constructor(...args:any[]) {
      super(...args)
    }
    isEmpty() {
      return this.length === 0
    }
  }

  let arr = new PowerArray(1, 2, 5, 10, 50)
  // let arr = [1, 2, 5, 10, 50] as PowerArray
  console.log(arr.isEmpty()) // false

  let filteredArr = arr.filter(item => item >= 10) as PowerArray
  console.log(filteredArr) // 10, 50
  console.log(filteredArr.isEmpty()) // false
  console.log(PowerArray.isArray([1,1]))
  Date.now()

  const arrayMixin = {
    isEmpty():boolean {
      // @ts-ignore
      return this.length === 0
    }
  }
  Object.assign(Array.prototype, arrayMixin)
  
  // type ExtArr = Array<any> & { isEmpty: ()=>boolean }

  // const newArr = [1, 2, 5] as ExtArr
  // newArr.isEmpty()
  // const filtred = newArr.filter(el => el > 6) as ExtArr
  // filtred.isEmpty()
  const arr1:any[] = [] 
  // @ts-ignore
  console.log('arr1.isEmpty()',arr1.isEmpty())
  arr1.push(1)
  // @ts-ignore
  console.log('arr1.isEmpty()', arr1.isEmpty())
}


// Давайте обобщим, какие методы для проверки типа мы знаем:

// ?работает для	возвращает
// !typeof	примитивов	строка
// !{}.toString	примитивов, встроенных объектов, объектов с Symbol.toStringTag	строка
// !instanceof	объектов	true/false
// Как мы можем видеть, технически {}.toString «более продвинут», чем typeof.

// А оператор instanceof – отличный выбор, когда мы работаем с иерархией классов и хотим делать проверки с учётом наследования.

const tempTimerDiv = document.querySelector('#timer') as Element
// tempTimerDiv.value у класса Element такого свойства нет
console.log('Node', tempTimerDiv instanceof Node)
console.log('EventTarget', tempTimerDiv instanceof EventTarget)
console.log('HTMLElement', tempTimerDiv instanceof HTMLElement)
console.log('HTMLDivElement', tempTimerDiv instanceof HTMLDivElement)
const HTMLtempTimerDiv = tempTimerDiv as HTMLInputElement
HTMLtempTimerDiv.value // у класса HTMLInputElement есть
HTMLtempTimerDiv.checked
console.log('HTMLElement', HTMLtempTimerDiv instanceof HTMLElement)
console.log('HTMLDivElement', HTMLtempTimerDiv instanceof HTMLDivElement)
console.log('HTMLInputElement', HTMLtempTimerDiv instanceof HTMLInputElement)
console.log('{}.toString.call(HTMLDivElement)', {}.toString.call(HTMLDivElement))


// Примесь – общий термин в объектно - ориентированном программировании: класс, который содержит в себе методы для других классов.

// Некоторые другие языки допускают множественное наследование.JavaScript не поддерживает множественное наследование, но с помощью примесей мы можем реализовать нечто похожее, скопировав методы в прототип.

// Мы можем использовать примеси для расширения функциональности классов, например, для обработки событий, как мы сделали это выше.

// С примесями могут возникнуть конфликты, если они перезаписывают существующие методы класса.Стоит помнить об этом и быть внимательнее при выборе имён для методов примеси, чтобы их избежать.

const mixin = {
  myName() {
    // @ts-ignore
    console.log(this.tagName)
  }
}

Object.assign(Element.prototype, mixin)

const tempInput = document.querySelector('#name') as HTMLInputElement

// @ts-ignore
tempTimerDiv.myName()
// @ts-ignore
HTMLtempTimerDiv.myName()
// @ts-ignore
tempInput.myName()
console.log(tempInput.tagName)

const renderDiv = document.getElementById('render') as HTMLDivElement
// document.body.innerHTML += 'Ещё текст из js'
// renderDiv.innerHTML += '<b>Ещё текст из js</b>'

// renderDiv.innerHTML = '' // Самый простой способ очистить содержимое элемента

// renderDiv.insertAdjacentHTML('afterend', '<i>После блока div</i>')

// renderDiv.insertAdjacentHTML('beforeend', '<hr>')
// renderDiv.insertAdjacentHTML('beforeend', '<b>В конце блока div</b>')

// renderDiv.insertAdjacentHTML('beforebegin', '<i>До блока div</i>')

// renderDiv.insertAdjacentHTML('afterbegin', '<b>В начале блока div</b>')

// Реализовать класс PrintMaсhine, которой состоит из:
// ■ размера шрифта;
// ■ цвета шрифта;
// ■ семейства шрифта;
// ■ метода print(), который принимает текст и печатает его
// соответствующим шрифтом с помощью document.write().
// Создать объект такого класса и продемонстрировать работу
// метода.

class PrintMaсhine {
  size
  color
  font
  constructor(size:number,color:string, font:string) {
    this.size = size
    this.color = color
    this.font = font
  }
  print(text:string) {
    renderDiv.insertAdjacentHTML('beforeend', 
      `<p style="color:${this.color};font-size:${this.size}px; font-family: ${this.font}">${text}</p>`)
  }
}

const redMachine = new PrintMaсhine(10, 'red', 'Arial')
redMachine.print('sdfgfsd fsdfs dfsdf sdf')
const purpleMachine = new PrintMaсhine(12, 'purple', 'Tahoma')
purpleMachine.print('sdfgfsd fsdfs dfsdf sdf')

const textArr = ['Lorem ipsum dolor sit, amet consectetur adipisicing elit.', 'Delectus ex sequi reiciendis obcaecati accusamus repellendus animi expedita nihil similique deserunt.','Tempora cumque consequatur libero deleniti eaque, doloribus voluptatum dicta alias?']

textArr.forEach(el=>purpleMachine.print(el))


//   Задание 3
//   Реализовать класс Employee, описывающий работника, и со-
//   здать массив работников банка.
//   Реализовать класс EmpTable для генерации html кода таблицы
//   со списком работников банка. Массив работников необходимо
//   передавать через конструктор, а получать html код с помощью
//   метода getHtml().
//   Создать объект класса EmpTable и вывести на экран результат
//   работы метода getHtml().

class Employee{
  static id = localStorage.staticId || 1
  id
  name
  salary
  constructor(name: string, salary: number){
    this.id = Employee.id++
    this.name = name
    this.salary = salary
    localStorage.staticId = Employee.id
  }
}

const empArr = localStorage.empArr ? JSON.parse(localStorage.empArr) : [
  new Employee('Санек',40_000,),
  new Employee('Леха',40_000,),
  new Employee('Никитос',60_000,),
  new Employee('Андрюха',40_000,),
  new Employee('Ванечка',50_000,),
]

let addEmploye = document.querySelector('.addEmploye') as HTMLButtonElement
let buttonState = 'add'
let empId = document.querySelector('.id') as HTMLInputElement
let empName = document.querySelector('.name') as HTMLInputElement
let empSalary = document.querySelector('.salary') as HTMLInputElement
let table = document.querySelector('.table') as HTMLDivElement

addEmploye.addEventListener('click', ()=>{
  if (empName.value && empSalary.value) {
    if (buttonState == 'add') {
      empTable.addEmployee(new Employee(empName.value, parseInt(empSalary.value)))
    } else {
      empTable.editEmployee(+empId.value, empName.value, parseInt(empSalary.value))
    }
    empId.value = ''
    empName.value = ''
    empSalary.value = ''
    empTable.render()
    addEmploye.textContent = 'Добавить'
    buttonState = 'add'
  }
})

table.addEventListener('click', (e)=>{
  const target = e.target as HTMLElement
  if (target.dataset.action == 'delete') {
    if (target.dataset.id) empTable.removeEmployee(+target.dataset.id)
    empTable.render()
  }
  if (target.dataset.action == 'edit') {
    addEmploye.textContent = 'Сохранить'
    buttonState = 'edit'
    if (target.dataset.id) {
      const el = empTable.getEmployeeData(+target.dataset.id)
      empId.value = el?.id.toString() || ''
      empName.value = el?.name || ''
      empSalary.value = el?.salary.toString() || ''
    }
  }
})

class EmployeeTable {
  table
  constructor(table:Employee[]) {
    this.table = table
  }
  addEmployee(el:Employee) {
    this.table.push(el)
  }
  editEmployee(id:number, name:string, salary:number) {
    const i = this.table.findIndex(emp => emp.id == id)
    this.table[i].name = name
    this.table[i].salary = salary
  }
  removeEmployee(id:number) {
    const i = this.table.findIndex(el => el.id == id)
    this.table.splice(i,1)
  }
  getEmployeeData(id:number) {
    return this.table.find(el => el.id == id)
  }
  getHtml() {
    let tableHtml = `
      <table>
        <thead>
          <tr>
            <th>№</th>
            <th>Name</th>
            <th>Salary</th>
            <th>Action</th>
          </tr>
        </thead>
      <tbody>`
    this.table.forEach((el,i)=>{
      tableHtml += `
      <tr>
        <td>${i+1}</td>
        <td>${el.name}</td>
        <td>${el.salary}</td>
        <td>
          <button data-action="edit" data-id="${el.id}">✎</button>
          <button data-action="delete" data-id="${el.id}">☠</button>
        </td>
      </tr>`
    })
    tableHtml += `</tbody></table>`
    return tableHtml
  }
  render() {
    table.innerHTML = this.getHtml()   
    localStorage.empArr = JSON.stringify(this.table) 
  }
}

const empTable = new EmployeeTable(empArr)
empTable.render()

// JSON – это формат данных, который имеет собственный независимый стандарт и библиотеки для большинства языков программирования.
// JSON поддерживает простые объекты, массивы, строки, числа, логические значения и null.
// JavaScript предоставляет методы JSON.stringify для сериализации в JSON и JSON.parse для чтения из JSON.
// Оба метода поддерживают функции преобразования для интеллектуального чтения / записи.
// Если объект имеет метод toJSON, то он вызывается через JSON.stringify.

{
  // ?Метод Object.getOwnPropertyDescriptor позволяет получить полную информацию о свойстве.
  let user = {
    name: "John",
  } as any

  let descriptor = Object.getOwnPropertyDescriptor(user, 'name');

  console.log(JSON.stringify(descriptor, null, 2));
  /* дескриптор свойства:
  {
    "value": "John",
    "writable": true,
    "enumerable": true,
    "configurable": true
  }
  */

  // ?Чтобы изменить флаги, мы можем использовать метод Object.defineProperty.
  // !Если свойство существует, defineProperty обновит его флаги.В противном случае метод создаёт новое свойство с указанным значением и флагами; если какой - либо флаг не указан явно, ему присваивается значение false.

  Object.defineProperty(user, "age", {
    value: "22",
    configurable: true
  })

  // !Обратите внимание: configurable: false не даст изменить флаги свойства, а также не даст его удалить.При этом можно изменить значение свойства, если флаг writable равен true

  descriptor = Object.getOwnPropertyDescriptor(user, 'age');

  console.log(JSON.stringify(descriptor, null, 2));
  /*
  {
    "value": "22",
    "writable": false,
    "enumerable": false,
    "configurable": false
  }
   */

  try {
    user.age = 23
    delete user.age
  } catch(e) {
    console.log(e)
  }

  Object.defineProperty(user, "age", {
    value: "22",
    writable: true
  })

  user.age = 23

  console.log(Object.keys(user))
  
  Object.defineProperty(user, "age", {
    value: user.age,
    writable: true,
    enumerable:true
  })

  console.log(Object.keys(user))

  // ?Существует метод Object.defineProperties(obj, descriptors), который позволяет определять множество свойств сразу.

  // Его синтаксис:

  // Object.defineProperties(obj, {
  //   prop1: descriptor1,
  //   prop2: descriptor2
  //   ...
  // });
  
  Object.defineProperties(user, {
    name: { value: "John", writable: false },
    surname: { value: "Smith", writable: false },
    // ...
  })

  // Object.getOwnPropertyDescriptors
  // Чтобы получить все дескрипторы свойств сразу, можно воспользоваться методом Object.getOwnPropertyDescriptors(obj).

  // !Вместе с Object.defineProperties этот метод можно использовать для клонирования объекта вместе с его флагами:

  let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(user))

// Глобальное запечатывание объекта
// Дескрипторы свойств работают на уровне конкретных свойств.

// Но ещё есть методы, которые ограничивают доступ ко всему объекту:

// ?    Object.preventExtensions(obj)
// Запрещает добавлять новые свойства в объект.
// ?    Object.seal(obj)
// Запрещает добавлять / удалять свойства.Устанавливает configurable: false для всех существующих свойств.
// ?    Object.freeze(obj)
// Запрещает добавлять / удалять / изменять свойства.Устанавливает configurable: false, writable: false для всех существующих свойств.

// А также есть методы для их проверки:
// ?    Object.isExtensible(obj)
// Возвращает false, если добавление свойств запрещено, иначе true.
// ?    Object.isSealed(obj)
// Возвращает true, если добавление / удаление свойств запрещено и для всех существующих свойств установлено configurable: false.
// ?    Object.isFrozen(obj)
// Возвращает true, если добавление / удаление / изменение свойств запрещено, и для всех текущих свойств установлено configurable: false, writable: false.
// На практике эти методы используются редко.
}

// HTML/XML документы представлены в браузере в виде DOM-дерева.

// Теги становятся узлами-элементами и формируют структуру документа.
// Текст становится текстовыми узлами.
// … и т.д. Всё, что записано в HTML, есть и в DOM-дереве, даже комментарии.
// Для изменения элементов или проверки DOM-дерева мы можем использовать инструменты разработчика в браузере.

// ionic

// Получив DOM-узел, мы можем перейти к его ближайшим соседям используя навигационные ссылки.

// Есть два основных набора ссылок:

// Для всех узлов: parentNode, childNodes, firstChild, lastChild, previousSibling, nextSibling.
// Только для узлов-элементов: parentElement, children, firstElementChild, lastElementChild, previousElementSibling, nextElementSibling.
// Некоторые виды DOM-элементов, например таблицы, предоставляют дополнительные ссылки и коллекции для доступа к своему содержимому.

// Работает, но не ясно почему
// console.log(svet)
// console.log(window.svet)
// Лучше использовать document.getElementById
// Метод getElementById можно вызвать только для объекта document. Он осуществляет поиск по id по всему документу

// Есть 6 основных методов поиска элементов в DOM:

// Метод	                  Ищет по...	Ищет внутри элемента ? Возвращает живую коллекцию ?
// querySelector	          CSS-selector	        ✔	                      -
// querySelectorAll	        CSS-selector	        ✔	                      -
// getElementById	              id                -                        -
// getElementsByName	         name               -	                       ✔
// getElementsByTagName	     tag or '*'	          ✔	                       ✔
// getElementsByClassName	    class	              ✔	                       ✔

// Безусловно, наиболее часто используемыми в настоящее время являются методы querySelector и querySelectorAll, но и методы getElement(s)By * могут быть полезны в отдельных случаях, а также встречаются в старом коде.

// Кроме того:

// ?Есть метод elem.matches(css), который проверяет, удовлетворяет ли элемент CSS - селектору.
// ?Метод elem.closest(css) ищет ближайшего по иерархии предка, соответствующему данному CSS - селектору.Сам элемент также включён в поиск.
// И, напоследок, давайте упомянем ещё один метод, который проверяет наличие отношений между предком и потомком:

// ?elemA.contains(elemB) вернёт true, если elemB находится внутри elemA(elemB потомок elemA) или когда elemA == elemB.

const firstAnchor = document.querySelector('a') as HTMLAnchorElement
const firstInput = document.querySelector('input') as HTMLInputElement

console.log(firstAnchor?.href)
console.log(firstInput.value)

console.log(document.body.constructor.name) // HTMLBodyElement
console.log(document.body.tagName) // BODY
console.log(document.documentElement.tagName) // HTML
// @ts-ignore
console.log(document.tagName) // undefined (не элемент)
console.log(document.nodeName) // #document (не элемент)
// Если мы имеем дело только с элементами, то можно использовать tagName или nodeName, нет разницы.

console.log(document.body instanceof HTMLBodyElement) // true
console.log(document.body instanceof HTMLElement) // true
console.log(document.body instanceof Element) // true
console.log(document.body instanceof Node) // true
console.log(document.body instanceof EventTarget) // true


console.log(firstAnchor)
console.dir(firstAnchor)

// innerHTML
// !Будьте внимательны: «innerHTML+=» осуществляет перезапись
// !Так как содержимое «обнуляется» и переписывается заново, все изображения и другие ресурсы будут перезагружены.

// outerHTML
// !outerHTML: HTML элемента целиком
// !Свойство outerHTML содержит HTML элемента целиком.Это как innerHTML плюс сам элемент.
// !Будьте осторожны: в отличие от innerHTML, запись в outerHTML не изменяет элемент. Вместо этого элемент заменяется целиком во внешнем контексте.

// textContent: просто текст
// !Намного полезнее возможность записывать текст в textContent, т.к. позволяет писать текст «безопасным способом».
// !Представим, что у нас есть произвольная строка, введённая пользователем, и мы хотим показать её.
// !С innerHTML вставка происходит «как HTML», со всеми HTML-тегами.
// !С textContent вставка получается «как текст», все символы трактуются буквально.


const elem = document.querySelector('#render p span') as HTMLParagraphElement
setInterval(() => elem.hidden = !elem.hidden, 1000)

// !Итого
// Каждый DOM-узел принадлежит определённому классу. Классы формируют иерархию. Весь набор свойств и методов является результатом наследования.
// Главные свойства DOM-узла:
// ?nodeType
// Свойство nodeType позволяет узнать тип DOM-узла. Его значение – числовое: 1 для элементов,3 для текстовых узлов, и т.д. Только для чтения.
// ?nodeName/tagName
// Для элементов это свойство возвращает название тега (записывается в верхнем регистре, за исключением XML-режима). Для узлов-неэлементов nodeName описывает, что это за узел. Только для чтения.
// ?innerHTML
// Внутреннее HTML-содержимое узла-элемента. Можно изменять.
// ?outerHTML
// Полный HTML узла-элемента. Запись в elem.outerHTML не меняет elem. Вместо этого она заменяет его во внешнем контексте.
// ?nodeValue/data
// Содержимое узла-неэлемента (текст, комментарий). Эти свойства практически одинаковые, обычно мы используем data. Можно изменять.
// ?textContent
// Текст внутри элемента: HTML за вычетом всех <тегов>. Запись в него помещает текст в элемент, при этом все специальные символы и теги интерпретируются как текст. Можно использовать для защиты от вставки произвольного HTML кода.
// ?hidden
// Когда значение установлено в true, делает то же самое, что и CSS display:none.

// !DataSet
// ?Все атрибуты, начинающиеся с префикса «data-», зарезервированы для использования программистами. Они доступны в свойстве dataset.
// ?Например, если у elem есть атрибут "data-about", то обратиться к нему можно как elem.dataset.about.
// Использование data-* атрибутов – валидный, безопасный способ передачи пользовательских данных.

// !Атрибуты – это то, что написано в HTML.
// !Свойства – это то, что находится в DOM - объектах.

// Небольшое сравнение:
//                                  Свойства	                                              Атрибуты
// Тип	    Любое значение, стандартные свойства имеют типы, описанные в спецификации	       Строка
// Имя	                    Имя регистрозависимо	                                   Имя регистронезависимо

// Методы для работы с атрибутами:
// ?elem.hasAttribute(name) – проверить на наличие.
// ?elem.getAttribute(name) – получить значение.
// ?elem.setAttribute(name, value) – установить значение.
// ?elem.removeAttribute(name) – удалить атрибут.
// ?elem.attributes – это коллекция всех атрибутов.
// !В большинстве ситуаций предпочтительнее использовать DOM - свойства.Нужно использовать атрибуты только тогда, когда DOM - свойства не подходят, когда нужны именно атрибуты, например:

// ?Нужен нестандартный атрибут.Но если он начинается с data -, тогда нужно использовать dataset.
// ?Мы хотим получить именно то значение, которое написано в HTML.Значение DOM - свойства может быть другим, например, свойство href – всегда полный URL, а нам может понадобиться получить «оригинальное» значение.

// !Стили и классы
// !Свойство style оперирует только значением атрибута "style", без учёта CSS-каскада

// Для управления классами существуют два DOM - свойства:

// className – строковое значение, удобно для управления всем набором классов.
//   classList – объект с методами add / remove / toggle / contains, удобно для управления отдельными классами.
// Чтобы изменить стили:

// Свойство style является объектом со стилями в формате camelCase.Чтение и запись в него работают так же, как изменение соответствующих свойств в атрибуте "style".Чтобы узнать, как добавить в него important и делать некоторые другие редкие вещи – смотрите документацию.

// Свойство style.cssText соответствует всему атрибуту "style", полной строке стилей.

// Для чтения окончательных стилей(с учётом всех классов, после применения CSS и вычисления окончательных значений) используется:

// Метод getComputedStyle(elem, [pseudo]) возвращает объект, похожий по формату на style.Только для чтения.

// У элементов есть следующие геометрические свойства(метрики):

// offsetParent – ближайший CSS - позиционированный родитель или ближайший td, th, table, body.
// offsetLeft / offsetTop – позиция в пикселях верхнего левого угла относительно offsetParent.
// offsetWidth / offsetHeight – «внешняя» ширина / высота элемента, включая рамки.
// clientLeft / clientTop – расстояние от верхнего левого внешнего угла до внутренного.Для операционных систем с ориентацией слева - направо эти свойства равны ширинам левой / верхней рамки.Если язык ОС таков, что ориентация справа налево, так что вертикальная полоса прокрутки находится не справа, а слева, то clientLeft включает в своё значение её ширину.

// clientWidth / clientHeight – ширина / высота содержимого вместе с внутренними отступами padding, но без полосы прокрутки.
// scrollWidth / scrollHeight – ширины / высота содержимого, аналогично clientWidth / Height, но учитывают прокрученную, невидимую область элемента.
// scrollLeft / scrollTop – ширина / высота прокрученной сверху части элемента, считается от верхнего левого угла.
// Все свойства доступны только для чтения, кроме scrollLeft / scrollTop, изменение которых заставляет браузер прокручивать элемент.

const block = document.querySelector('.block') as HTMLDivElement

block.addEventListener('click', (e)=>{
  const target = e.target as HTMLDivElement
  if (!isDrug && target.classList.contains('absolute')) return
  if (!isDrug) target.classList.toggle('absolute')
})

let isDrug = false

block.addEventListener('mousedown', ()=>{
  isDrug = true  
})

block.addEventListener('mouseup', ()=>{
  isDrug = false
})

document.addEventListener('mousemove', (e)=>{
  if (isDrug) {
    block.style.top = window.scrollY + e.clientY + 'px'
    block.style.left = e.clientX + 'px'
  }
})

const getSize = () => {
  const imgEl = document.querySelector('img') as HTMLImageElement
  if (imgEl) {
    console.log(imgEl.offsetHeight)
    console.log(imgEl.offsetWidth)
  }
}

// Ждём, пока бразер загрузит изображение, а затем читаем высоту/ширину
window.addEventListener('load', getSize)
// window.removeEventListener('load', getSize)

// !Размеры и прокрутка окна

// Размеры:
// Ширина / высота видимой части документа(ширина / высота области содержимого): document.documentElement.clientWidth / Height
// Ширина / высота всего документа со всей прокручиваемой областью страницы:

let scrollHeight = Math.max(
  document.body.scrollHeight, document.documentElement.scrollHeight,
  document.body.offsetHeight, document.documentElement.offsetHeight,
  document.body.clientHeight, document.documentElement.clientHeight
)

// Прокрутка:
// Прокрутку окна можно получить так: window.scrollX, window.scrollY

// Изменить текущую прокрутку:

// window.scrollTo(pageX, pageY) – абсолютные координаты,
// window.scrollBy(x, y) – прокрутка относительно текущего места,
// elem.scrollIntoView(top) – прокрутить страницу так, чтобы сделать elem видимым(выровнять относительно верхней / нижней части окна).

// Пример, как сделать скролл к элементу с запасом в Xpx
// const scrollDiv = document.getElementById("myDiv").offsetTop
// window.scrollTo({ top: scrollDiv - 70, behavior: 'smooth' })

// !Координаты

// Любая точка на странице имеет координаты:

// Относительно окна браузера – elem.getBoundingClientRect().
// Относительно документа – elem.getBoundingClientRect() плюс текущая прокрутка страницы.
// Координаты в контексте окна подходят для использования с position:fixed, а координаты относительно документа – для использования с position:absolute.

// Каждая из систем координат имеет свои преимущества и недостатки. Иногда будет лучше применить одну, а иногда – другую, как это и происходит с позиционированием в CSS, где мы выбираем между absolute и fixed.

// События

// document.addEventListener('click', (e)=>{console.log(e)})
// document.addEventListener('mousemove', (e)=>{console.log(e)})
// document.addEventListener('keydown', (e)=>{console.log(e)})

// Есть три способа назначения обработчиков событий:

// Атрибут HTML: onclick = "...".
// DOM - свойство: elem.onclick = function.
// Специальные методы: elem.addEventListener(event, handler[, phase]) для добавления, removeEventListener для удаления.

// ?options
// Дополнительный объект со свойствами:
// once: если true, тогда обработчик будет автоматически удалён после выполнения.
// capture: фаза, на которой должен сработать обработчик, подробнее об этом будет рассказано в главе Всплытие и погружение.Так исторически сложилось, что options может быть false / true, это то же самое, что { capture: false / true }.
// passive: если true, то указывает, что обработчик никогда не вызовет preventDefault(), подробнее об этом будет рассказано в главе Действия браузера по умолчанию.


// HTML - атрибуты используются редко потому, что JavaScript в HTML - теге выглядит немного странно.К тому же много кода там не напишешь.

// DOM - свойства вполне можно использовать, но мы не можем назначить больше одного обработчика на один тип события.Во многих случаях с этим ограничением можно мириться.

// Последний способ самый гибкий, однако нужно писать больше всего кода.Есть несколько типов событий, которые работают только через него, например, DOMContentLoaded.Также addEventListener поддерживает объекты в качестве обработчиков событий.В этом случае вызывается метод объекта handleEvent.

// Не важно, как вы назначаете обработчик – он получает объект события первым аргументом.Этот объект содержит подробности о том, что произошло.

const firstButton = document.querySelector('button') as HTMLButtonElement
firstButton.addEventListener('click', function(e) {
  console.log(this)
  console.log(e.target)
  // @ts-ignore
  e.myData = 'Нажата самая важная кнопка'
  console.log(e)
}, {capture:true})
document.addEventListener('click', (e)=>{
  // @ts-ignore
  if (e.myData) {
    console.log(e)
    // @ts-ignore
    console.log(e.myData)
  }
})

// !Не прекращайте всплытие без необходимости!
// Всплытие – это удобно. Не прекращайте его без явной нужды, очевидной и архитектурно прозрачной.

// Зачастую прекращение всплытия через event.stopPropagation() имеет свои подводные камни, которые со временем могут стать проблемами.

// Например:

// Мы делаем вложенное меню. Каждое подменю обрабатывает клики на своих элементах и делает для них stopPropagation, чтобы не срабатывало внешнее меню.
// Позже мы решили отслеживать все клики в окне для какой-то своей функциональности, к примеру, для статистики – где вообще у нас кликают люди. Некоторые системы аналитики так делают. Обычно используют document.addEventListener('click'…), чтобы отлавливать все клики.
// Наша аналитика не будет работать над областью, где клики прекращаются stopPropagation. Увы, получилась «мёртвая зона».
// Зачастую нет никакой необходимости прекращать всплытие. Задача, которая, казалось бы, требует этого, может быть решена иначе. Например, с помощью создания своего уникального события, о том, как это делать, мы поговорим позже. Также мы можем записывать какую-то служебную информацию в объект event в одном обработчике, а читать в другом, таким образом мы можем сообщить обработчикам на родительских элементах информацию о том, что событие уже было как-то обработано.

// При наступлении события – самый глубоко вложенный элемент, на котором оно произошло, помечается как «целевой» (event.target).

// Затем событие сначала двигается вниз от корня документа к event.target, по пути вызывая обработчики, поставленные через addEventListener(...., true), где true – это сокращение для { capture: true }.
// Далее обработчики вызываются на целевом элементе.
// Далее событие двигается от event.target вверх к корню документа, по пути вызывая обработчики, поставленные через on < event > и addEventListener без третьего аргумента или с третьим аргументом равным false.
// Каждый обработчик имеет доступ к свойствам события event:

// event.target – самый глубокий элемент, на котором произошло событие.
//   event.currentTarget(=this) – элемент, на котором в данный момент сработал обработчик(тот, на котором «висит» конкретный обработчик)
// event.eventPhase – на какой фазе он сработал(погружение = 1, фаза цели = 2, всплытие = 3).
// Любой обработчик может остановить событие вызовом event.stopPropagation(), но делать это не рекомендуется, так как в дальнейшем это событие может понадобиться, иногда для самых неожиданных вещей.

// В современной разработке стадия погружения используется очень редко, обычно события обрабатываются во время всплытия.И в этом есть логика.

// В реальном мире, когда происходит чрезвычайная ситуация, местные службы реагируют первыми.Они знают лучше всех местность, в которой это произошло, и другие детали.Вышестоящие инстанции подключаются уже после этого и при необходимости.

// Тоже самое справедливо для обработчиков событий.Код, который «навесил» обработчик на конкретный элемент, знает максимум деталей об элементе и его предназначении.Например, обработчик на определённом < td > скорее всего подходит только для этого конкретного<td>, он знает все о нём, поэтому он должен отработать первым.Далее имеет смысл передать обработку события родителю – он тоже понимает, что происходит, но уже менее детально, далее – выше, и так далее, до самого объекта document, обработчик на котором реализовывает самую общую функциональность уровня документа.

// Всплытие и погружение являются основой для «делегирования событий» – очень мощного приёма обработки событий.Его мы изучим в следующей главе.


// !Всегда используйте метод addEventListener для обработчиков на уровне документа
// Когда мы устанавливаем обработчик событий на объект document, мы всегда должны использовать метод addEventListener, а не document.on<событие>, т.к. в случае последнего могут возникать конфликты: новые обработчики будут перезаписывать уже существующие.

// Для реального проекта совершенно нормально иметь много обработчиков на элементе document, установленных из разных частей кода.

// Делегирование событий – это здорово! Пожалуй, это один из самых полезных приёмов для работы с DOM.

// Он часто используется, если есть много элементов, обработка которых очень схожа, но не только для этого.

// Алгоритм:

// Вешаем обработчик на контейнер.
// В обработчике проверяем исходный элемент event.target.
// Если событие произошло внутри нужного нам элемента, то обрабатываем его.
// Зачем использовать:

// Упрощает процесс инициализации и экономит память: не нужно вешать много обработчиков.
// Меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики.
// Удобство изменений DOM: можно массово добавлять или удалять элементы путём изменения innerHTML и ему подобных.
//   Конечно, у делегирования событий есть свои ограничения:

// Во - первых, событие должно всплывать.Некоторые события этого не делают.Также, низкоуровневые обработчики не должны вызывать event.stopPropagation().
// Во - вторых, делегирование создаёт дополнительную нагрузку на браузер, ведь обработчик запускается, когда событие происходит в любом месте контейнера, не обязательно на элементах, которые нам интересны.Но обычно эта нагрузка настолько пустяковая, что её даже не стоит принимать во внимание.

// !Действий браузера по умолчанию достаточно много:

// mousedown – начинает выделять текст (если двигать мышкой).
// click на <input type="checkbox"> – ставит или убирает галочку в input.
// submit – при нажатии на <input type="submit"> или при нажатии клавиши Enter в форме данные отправляются на сервер.
// keydown – при нажатии клавиши в поле ввода появляется символ.
// contextmenu – при правом клике показывается контекстное меню браузера.
// …и многие другие…
// Все эти действия можно отменить, если мы хотим обработать событие исключительно при помощи JavaScript.

// Чтобы отменить действие браузера по умолчанию, используйте event.preventDefault() или return false. Второй метод работает, только если обработчик назначен через on<событие>.

// Опция passive: true для addEventListener сообщает браузеру, что действие по умолчанию не будет отменено. Это очень полезно для некоторых событий на мобильных устройствах, таких как touchstart и touchmove, чтобы сообщить браузеру, что он не должен ожидать выполнения всех обработчиков, а ему следует сразу приступать к выполнению действия по умолчанию, например, к прокрутке.

// Если событие по умолчанию отменено, то значение event.defaultPrevented становится true, иначе false.

// Сохраняйте семантику, не злоупотребляйте
// Технически, отменяя действия браузера по умолчанию и добавляя JavaScript, мы можем настроить поведение любого элемента. Например, мы можем заставить ссылку <a> работать как кнопку, а кнопку <button> вести себя как ссылка (перенаправлять на другой URL).

// Но нам следует сохранять семантическое значение HTML элементов. Например, не кнопки, а тег <a> должен применяться для переходов по ссылкам.

// Помимо того, что это «хорошо», это делает ваш HTML лучше с точки зрения доступности для людей с ограниченными возможностями и с особых устройств.

// Также, если мы рассматриваем пример с тегом <a>, то обратите внимание: браузер предоставляет возможность открывать ссылки в новом окне (кликая правой кнопкой мыши или используя другие возможности). И пользователям это нравится. Но если мы заменим ссылку кнопкой и стилизуем её как ссылку, используя CSS, то специфичные функции браузера для тега <a> всё равно работать не будут.

// !Чтобы сгенерировать событие из кода, вначале надо создать объект события.

// Базовый конструктор Event(name, options) принимает обязательное имя события и options – объект с двумя свойствами:

// bubbles: true чтобы событие всплывало.
// cancelable: true если мы хотим, чтобы event.preventDefault() работал.
// Особые конструкторы встроенных событий MouseEvent, KeyboardEvent и другие принимают специфичные для каждого конкретного типа событий свойства.Например, clientX для событий мыши.

// Для пользовательских событий стоит применять конструктор CustomEvent.У него есть дополнительная опция detail, с помощью которой можно передавать информацию в объекте события.После чего все обработчики смогут получить к ней доступ через event.detail.

// Несмотря на техническую возможность генерировать встроенные браузерные события типа click или keydown, пользоваться ей стоит с большой осторожностью.

// Весьма часто, когда разработчик хочет сгенерировать встроенное событие – это вызвано «кривой» архитектурой кода.

// Как правило, генерация встроенных событий полезна в следующих случаях:

// Либо как явный и грубый хак, чтобы заставить работать сторонние библиотеки, в которых не предусмотрены другие средства взаимодействия.
// Либо для автоматического тестирования, чтобы скриптом «нажать на кнопку» и посмотреть, произошло ли нужное действие.
// Пользовательские события со своими именами часто создают для улучшения архитектуры, чтобы сообщить о том, что происходит внутри наших меню, слайдеров, каруселей и т.д.

const imgArr = [
  '1.jpg',
  '2.jpg',
  '3.jpg',
  '4.jpg',
  '5.jpg',
  '6.jpg',
  '7.jpg',
  '8.JPG',
  '9.jpeg',
]

const renderSlider = (arr:string[]) => {
  let htmlString = `<div id="slider_div" class="slider_div">
      <div class="arrow fs">←</div>
      <div class="arrow sc">→</div>`
  for (let i=0; i<arr.length; i+=3) {
    if (i==0) {
      htmlString += `<div class="three_imgs bim" style="margin-left: 90px;" data-type="active">`
    } else {
      htmlString += `<div class="three_imgs">`
    }
    let to = (i + 2 < arr.length) ? i+2 : arr.length-1
    for (let a = i; a<=to; a++) {
      htmlString += `<img src="${arr[a]}" alt="" class="slider_img">`
    }
    htmlString += `</div>`
  }
  htmlString += `</div>`
  document.body.insertAdjacentHTML('beforeend', htmlString)
}

renderSlider(imgArr)

let marginLeft = document.querySelector('.bim') as HTMLDivElement
let sliderDiv = document.querySelector('.slider_div') as HTMLDivElement
let currentIndex = 0
const maxIndex = 2
sliderDiv.addEventListener('click', (event) => {
  let target = event.target as HTMLElement
  if (target.classList.contains('fs')) {
    if (currentIndex==0) {
      currentIndex = maxIndex
      marginLeft.style.marginLeft = 2*-800 + 90 +'px'
    } else {
      marginLeft.style.marginLeft = parseInt(marginLeft.style.marginLeft) + 800 +'px'
      currentIndex--
    }
  }
  if (target.classList.contains('sc')) {
    if (currentIndex == maxIndex) {
      currentIndex = 0
      marginLeft.style.marginLeft = 90 + 'px'

    } else {
      marginLeft.style.marginLeft = parseInt(marginLeft.style.marginLeft) + -800 + 'px'
      currentIndex++
    }
  }
})
