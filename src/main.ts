import './style.css'
// Комментарий
// alert('Я JS')
console.log('Я JS') // выводит в консоль "Я JS"

console.log(1 +
  2 +
  4)

  // ; ставится только перед квадратными скобками
  ;[1, 2].forEach(console.log)

/*
  Многострочный
  комментарий
*/

// Многострочный
// комментарий

// Объявили переменную m и присвоили ей значение 1 
let m = 1

// объявили несколько переменных через запятую
// let user = 'John', age = 25, message = 'Hello'
// Но лучше определять переменные на новой строке
let user = 'John'
let age = 25
let message = 'Hello'
console.log('значение переменной user', user)
user = 'Kate'
console.log('значение переменной user', user)
console.log('значение переменной age', age)
console.log('значение переменной message', message)


let hello = 'Hello world!'

// копируем значение 'Hello world' из переменной hello в переменную message
message = hello

// теперь две переменные содержат одинаковые данные
console.log('значение переменной hello', hello) // Hello world!
console.log('значение переменной message', message) // Hello world!

// Невозможно повторно объявить переменную "hello" с областью видимости "Блок"
// let hello

// При обращении к переменной, которая не была создана при помощи let, движок
// пытается найти её в коде выше, и если не находит, выводится ошибка
// Не удается найти имя "newVar"
// newVar = 10

// !Имена переменных
// В JavaScript есть два ограничения, касающиеся имён переменных:

// !Имя переменной должно содержать только буквы, цифры или символы $ и _.
// !Первый символ не должен быть цифрой.
// Примеры допустимых имён:

let userName
let test123
// Если имя содержит несколько слов, обычно используется верблюжья нотация, то есть, слова следуют одно за другим, где каждое следующее слово начинается с заглавной буквы: myVeryLongName.
// Самое интересное – знак доллара '$' и подчёркивание '_' также можно использовать в названиях.Это обычные символы, как и буквы, без какого - либо особого значения.
// Эти имена являются допустимыми:

let $ = 1; // объявили переменную с именем "$"
let _ = 2; // а теперь переменную с именем "_"

console.log($ + _); // 3

// Создали переменную, имя которой начинается на число
// Идентификатор или ключевое слово не может следовать непосредственно за числовым литералом
// let 1a // не может начинаться с цифры
// let my-name // дефис '-' не разрешён в имени (возпринимается как минус)

// Регистр имеет значение
// Переменные с именами apple и APPLE – это две разные переменные.

// Нелатинские буквы разрешены, но не рекомендуются
// Можно использовать любой язык, включая кириллицу или даже иероглифы, например:

let имя = '...'
let 我 = '...'


// !Зарезервированные имена
// Существует список зарезервированных слов, которые нельзя использовать в качестве имён переменных, потому что они используются самим языком.

// Например: let, class, return и function зарезервированы.

// Приведённый ниже код даёт синтаксическую ошибку:

// let let = 5; // нельзя назвать переменную "let", ошибка!
// let return = 5; // также нельзя назвать переменную "return", ошибка!

// Константы
// Чтобы объявить константную, то есть, неизменяемую переменную, используйте const вместо let:

// Объявления "const" должны быть инициализированы (Должно быть присвоено значение)
// const myBirthday1

const myBirthday = '18.04.1982'
$ = 5
// Не удается задать значение для "myBirthday", так как это константа
// myBirthday = ''

// Константы в верхнем регистре
// Широко распространена практика использования констант в качестве псевдонимов для трудно запоминаемых значений, которые известны до начала исполнения скрипта.

// Названия таких констант пишутся с использованием заглавных букв и подчёркивания.

// Например, сделаем константы для различных цветов в «шестнадцатеричном формате»:

const COLOR_RED = "#F00"
const COLOR_GREEN = "#0F0"
const COLOR_BLUE = "#00F"
const COLOR_ORANGE = "#FF7F00"

// ...когда нам нужно выбрать цвет
let color = COLOR_ORANGE
console.log('color', color) // #FF7F00


// !Типы данных
// Значение в JavaScript всегда относится к данным определённого типа.Например, это может быть строка или число.

// Есть восемь основных типов данных в JavaScript.В этой главе мы рассмотрим их в общем, а в следующих главах поговорим подробнее о каждом.

// Когда мы присвоили какое-то значение переменной, тип этого значения сразу привязался к переменной
// Произошла неявная запись 
// let string:string = 'fsddfg'
let string = 'fsddfg'

// имяПеременной:any - такая запись говорит о том, что мы хотим, чтобы переменная хранила любое значение
let newMessage: any = "hello"
// либо мы можем указать после значения переменной as any
let newMessage2 = "hello" as any
newMessage = 123456
newMessage2 = 465

// !Число
let n = 123
n = 12.345
console.log('1_000_000', 1_000_000)
console.log('10e3', 10e3) // e3 == 10**3
console.log('1e-3', 1e-3) // e3 == 10**-3

console.log('typeof(n)', typeof (n)) // number
// Числовой тип данных(number) представляет как целочисленные значения, так и числа с плавающей точкой.

// Существует множество операций для чисел, например, умножение *, деление /, сложение +, вычитание - и так далее.

// Кроме обычных чисел, существуют так называемые «специальные числовые значения», которые относятся к этому типу данных: Infinity, -Infinity и NaN.

// Infinity представляет собой математическую бесконечность ∞. Это особое значение, которое больше любого числа.

// Мы можем получить его в результате деления на ноль:

console.log(1 / 0); // Infinity
// Или задать его явно:

console.log(Infinity); // Infinity
// NaN означает вычислительную ошибку.Это результат неправильной или неопределённой математической операции, например:

console.log(("не число" as any) / 2); // NaN, такое деление является ошибкой
// Значение NaN «прилипчиво». Любая математическая операция с NaN возвращает NaN:

console.log(NaN + 1); // NaN
console.log(3 * NaN); // NaN
// @ts-ignore
console.log("не число" / 2 - 1) // NaN
// Если где - то в математическом выражении есть NaN, то оно распространяется на весь результат(есть только одно исключение: NaN ** 0 равно 1).

// !символ "n" в конце означает, что это BigInt
const bigInt = 1234567890123456789012345678901234567890n
console.log('typeof(bigInt)', typeof (bigInt)) // bigint

// !Строка
// Строка (string) в JavaScript должна быть заключена в кавычки.

let str = "Привет dfssdf"
console.log('typeof(str)', typeof (str)) // string
// Предпочтительнее использовать одинарные либо косые кавычки для строк
// Для использования переноса строки в обычной строке, мы можем использовать специальный командный символ
// \n

// Обратная косая черта используется в паре с каким либо знаком в 2х вариантах: для экранирования или передачи командного символа

console.log('Строка с экранированной одинарной кавычкой', '\'')
console.log('Строка с экранированной двойной кавычкой', "\"str\"")
console.log('Обычная строка с\nпереносом строки и\tтабуляцией')

let str2 = 'Одинарные \r\n"кавычки" тоже подойдут It\'s'
// Строки с косыми кавычками поддерживаю перенос строки, а так же позволяют встраивать в себя значения переменных
// Их так же называют шаблонными строками
let phrase = `Обратные ${2 + 3}
'кавычки' позволяют 
"встраивать" переменные ${str}`



console.log('str2', str2)
console.log('phrase', phrase)

let name = 'Женя'
age = 23

// Такое встраивание хначений в строку называется интерполяцией
console.log(`Привет, меня зовут ${name}.
Мне ${age} лет.
Через месяц мне будет ${age + 1}`)

// Объявление пустой строки
let emptyString = ''

// !Булевый(логический) тип
// Булевый тип(boolean) может принимать только два значения: true(истина) и false(ложь).

// Такой тип, как правило, используется для хранения значений да / нет: true значит «да, правильно», а false значит «нет, не правильно».

let nameFieldChecked = true // да, поле отмечено
let ageFieldChecked = false // нет, поле не отмечено
// Булевые значения также могут быть результатом сравнений:

console.log('4 > 1', 4 > 1)
// @ts-ignore
console.log('4 == 2', 4 == 2)
console.log('typeof(true)', typeof (true)) // boolean

// !Значение «null»
// Специальное значение null не относится ни к одному из типов, описанных выше.

// Оно формирует отдельный тип, который содержит только значение null:

let newAge = null
// Тип значения null - null, но typeof возвращает object. Это ошибка typeof, ведущая начало с времён создания JavaScript и сохранённая для совместимости
console.log('typeof(null)', typeof (null)) // object
// В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках.

// Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».

// В приведённом выше коде указано, что значение переменной age неизвестно.

// !Значение «undefined»
// Специальное значение undefined также стоит особняком.Оно формирует тип из самого себя так же, как и null.

// Оно означает, что «значение не было присвоено».

// Если переменная объявлена, но ей не присвоено никакого значения, то её значением будет undefined:

let ageN

console.log(ageN) // выведет "undefined"
// Технически мы можем присвоить значение undefined любой переменной:

ageN = 123

// изменяем значение на undefined
ageN = undefined

console.log(ageN) // "undefined"
console.log('typeof(undefined)', typeof (undefined)) // undefined
// …Но так делать не рекомендуется.Обычно null используется для присвоения переменной «пустого» или «неизвестного» значения, а undefined – для проверок, была ли переменная назначена.

// !Объекты и символы
// Тип object(объект) – особенный.
console.log('typeof({})', typeof ({})) // object
// Все остальные типы называются «примитивными», потому что их значениями могут быть только простые значения(будь то строка, или число, или что - то ещё).В объектах же хранят коллекции данных или более сложные структуры.

// Объекты занимают важное место в языке и требуют особого внимания.Мы разберёмся с ними в главе Объекты после того, как узнаем больше о примитивах.

// Тип symbol(символ) используется для создания уникальных идентификаторов в объектах.Мы упоминаем здесь о нём для полноты картины, изучим этот тип после объектов.
console.log('typeof(Symbol("id"))', typeof Symbol('id')) // symbol

// Функция не является отдельным типом данных, но typeof возвращает для неё значение function
console.log('typeof(alert)', typeof alert) // function

// В JavaScript есть 8 основных типов данных.

// Семь из них называют «примитивными» типами данных:
// number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253 - 1).
// bigint для целых чисел произвольной длины.
// string для строк.Строка может содержать ноль или больше символов, нет отдельного символьного типа.
// boolean для true / false.
// null для неизвестных значений – отдельный тип, имеющий одно значение null.
// undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.
// symbol для уникальных идентификаторов.
// И один не является «примитивным» и стоит особняком:
// object для более сложных структур данных.
// Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.

// Имеет две формы: typeof x или typeof (x).
// Возвращает строку с именем типа.Например, "string".
// Для null возвращается "object" – это ошибка в языке, на самом деле это не объект.

// !!!Литералы JavaScript - это фиксированное значение, которое нельзя изменить, вам не нужно указывать какой - либо тип ключевого слова для записи литералов. Литералы часто используются для инициализации переменных в программировании, имена переменных являются строковыми литералами.

let num = 132

// функция alert выводит сообщение на экран, блокируя отображение
// функция prompt запрашивает у пользователя, блокируя отображение
// !Любой пользовательский ввод - это всегда строка!
// !Чтобы преобразовать строку в число, неободимо сделать преобразование
// parseInt - функция, которая достаёт целое число из строки, если эта строка начинается на число
// let input = parseInt(prompt('Введите число','0') as string)

// parseFloat - функция, которая достаёт число c плавающей запятой из строки, если эта строка начинается на число

// 1 Запросите у пользователя число, возведите это число во 2 - ю степень и выведите на экран.
// let input = parseFloat(prompt('Введите число','0') as string)
// alert(`sum ${input-input}
// div ${input+input}`)

// Показывает пользователю текст сообщения, на что пользователь может нажать ОК или отмена
// Если пользователь нажал ОК, возвращает true
// Если пользователь нажал отмена, возвращает false
// confirm('текст сообщения')

// !Преобразование значений примитивов
// ?Строковое преобразование

let value = true
console.log('typeof true', typeof value) // boolean

// функция String(value), преобразует значение к строке

let strValue = String(value) // теперь value это строка "true"
console.log('typeof "true"', typeof strValue) // string
console.log('String(1)', String(1))
console.log('String(null)', String(null))
console.log('String(undefined)', String(undefined))

// ?Численное преобразование

// !Численное преобразование происходит в математических функциях и выражениях.

// Например, когда операция деления / применяется не к числу:

// Операции, которые всегда неявно приводят операнды к числу, получаем число
// TS ругается, когда мы пытаемся делить строки
// @ts-ignore
console.log('"6" / "2"', "6" / "2") // 3, строки преобразуются в числа
// @ts-ignore
console.log('"6" * "2" =', "6" * "2") // 12
// @ts-ignore
console.log('"6" ** "2" =', "6" ** "2") // 36
// @ts-ignore  
console.log('"6" % "2" =', "6" % "2") // 6 на 2 делится целиком, остаток 0
// @ts-ignore  % - остаток от целочисленного деления
console.log('"7" % "2" =', "7" % "2") // 1
// @ts-ignore
console.log('"7.5" % "2" =', "7.5" % "2") // 1
// @ts-ignore
console.log('"6" - "2" =', "6" - "2") // 4


// Сложение строк называется конкатенацией. Эта поерация склеивает две строки в одну
console.log('"6" + "2" =', "6" + "2") // '62'
console.log('"6" + 2 =', "6" + 2) // '62'
console.log('6 + "2" =', 6 + "2") // '62'
// Операции сложения происходят слева на право
console.log('8 + 6 + "2" =', 8 + 6 + "2") // '142'
// Скобки имеют высший приоритет
console.log('"1" + (8 + 6) + "2" =', "1" + (8 + 6) + "2") // '1142'


// Мы можем использовать функцию Number(value), чтобы явно преобразовать value к числу:

str = "123"
console.log(typeof str) // string

num = Number(str) // становится числом 123

console.log(typeof num) // number

console.log('Number("1")', Number("1"))             // 1
console.log('Number("1(one)")', Number("1(one)"))   // NaN
console.log('Number(null)', Number(null))           // 0
console.log('Number(undefined)', Number(undefined)) // NaN

// Правила численного преобразования:

// Значение	Преобразуется в…
// undefined	NaN
// null	0
// true / false	1 / 0
// string	Пробельные символы(пробелы, знаки табуляции \t, знаки новой строки \n и т.п.) по краям обрезаются.
// Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число.
// При ошибке результат NaN.

console.log('Number("   123   ")', Number("   123   ")) // 123
console.log('Number("   \n\t   ")', Number("   \n\t   ")) // 0
console.log('Number("")', Number("")) // 0
console.log('Number("123z")', Number("123z"))      // NaN (ошибка чтения числа на месте символа "z")
console.log('Number(true)', Number(true))        // 1
console.log('Number(false)', Number(false))       // 0

// Короткая запись преобразования к числу
console.log('+true', +true)        // 1
console.log('+"2"', +"2")          // 2

console.log('3 + +"2"', 3 + +"2")  // 5
console.log('3 + Number("2")', 3 + Number("2"))  // 5

// ?Логическое преобразование

// Правило преобразования:

// Значения, которые интуитивно «пустые», вроде 0, пустой строки, null, undefined и NaN, становятся false.
// Все остальные значения становятся true

// !!! Здесь предствлены все значения, которые преобразуются к false
console.log('Здесь предствлены все значения, которые преобразуются к false')
console.log('Boolean(0)', Boolean(0)) // false
console.log('Boolean("")', Boolean("")) // false
console.log('Boolean(null)', Boolean(null)) // false
console.log('Boolean(undefined)', Boolean(undefined)) // false
console.log('Boolean(NaN)', Boolean(NaN)) // false

console.log('Boolean(-10)', Boolean(-10)) // true

console.log('Boolean("Привет!")', Boolean("Привет!")) // true
// Заметим, что строчка с нулём "0" — это true
// Некоторые языки(к примеру, PHP) воспринимают строку "0" как false.Но в JavaScript, если строка не пустая, то она всегда true.
// !!! Строка с пробелом и стока с нулём
console.log('Boolean("0")', Boolean("0")) // true
console.log('Boolean(" ")', Boolean(" ")) // пробел это тоже true (любая непустая строка это true)

// Короткая запись преобразования к булеву
console.log('!!" "', !!" ") // !! - двойное отрицание, краткая запись приведения к булеву

// Оператор ! и операция отрицания
console.log('!true', !true) // false 
console.log('!false', !false) // true
console.log('!0', !0) // true

// Термины: «унарный», «бинарный», «операнд»
// Прежде, чем мы двинемся дальше, давайте разберёмся с терминологией.

// Операнд – то, к чему применяется оператор.Например, в умножении 5 * 2 есть два операнда: левый операнд равен 5, а правый операнд равен 2. Иногда их называют «аргументами» вместо «операндов».

// Унарным называется оператор, который применяется к одному операнду.Например, оператор унарный минус "-" меняет знак числа на противоположный:

let x = 1

x = -x
console.log(x) // -1, применили унарный минус
// Бинарным называется оператор, который применяется к двум операндам.Тот же минус существует и в бинарной форме:

x = 1
let y = 3
console.log(y - x) // 2, бинарный минус вычитает значения
// Формально, в последних примерах мы говорим о двух разных операторах, использующих один символ: оператор отрицания(унарный оператор, который обращает знак) и оператор вычитания(бинарный оператор, который вычитает одно число из другого)

// Взятие остатка %
// Оператор взятия остатка %, несмотря на обозначение, никакого отношения к процентам не имеет.

// Результат a % b – это остаток от целочисленного деления a на b.

console.log(5 % 2) // 1, остаток от деления 5 на 2
console.log(8 % 3) // 2, остаток от деления 8 на 3
console.log(8 % 4) // 0, остаток от деления 8 на 4

// Математически, оператор работает и для нецелых чисел.Например, квадратный корень является возведением в степень 1 / 2:

console.log(4 ** (1 / 2)) // 2 (степень 1/2 эквивалентна взятию квадратного корня)
console.log(8 ** (1 / 3)) // 2 (степень 1/3 эквивалентна взятию кубического корня)

// ?Сокращённая арифметика с присваиванием

n = 2
n += 5 // теперь n = 7 (работает как n = n + 5)
n *= 2 // теперь n = 14 (работает как n = n * 2)
n /= 2 // теперь n = 7 (работает как n = n / 2)
n = 5 // теперь n = 2 (работает как n = n - 5)
n **= 2 // теперь n = 4 (работает как n = n ** 2)
n %= 3 // теперь n = 1 (работает как n = n % 3 )

// Инкремент / декремент
// Одной из наиболее частых числовых операций является увеличение или уменьшение на единицу.

// Для этого существуют даже специальные операторы:

// Инкремент++ увеличивает переменную на 1:

let counter = 2
counter++             // работает как counter = counter + 1, просто запись короче
console.log(counter)  // 3
// Декремент-- уменьшает переменную на 1:

counter = 2
counter--            // работает как counter = counter - 1, просто запись короче
console.log(counter) // 1

// !Инкремент / декремент можно применить только к переменной.Попытка использовать его на значении, типа 5++, приведёт к ошибке.

// Операторы++ и-- могут быть расположены не только после, но и до переменной.

// Когда оператор идёт после переменной — это «постфиксная форма»: counter++.
// «Префиксная форма» — это когда оператор идёт перед переменной: ++counter.
// Обе эти инструкции делают одно и то же: увеличивают counter на 1.

// Есть ли разница между ними ? Да, но увидеть её мы сможем, только если будем использовать значение, которое возвращают++ / --.

// Давайте проясним этот момент.Как мы знаем, все операторы возвращают значение.Операторы инкремента / декремента не исключение.Префиксная форма возвращает новое значение, в то время как постфиксная форма возвращает старое(до увеличения / уменьшения числа).

// Чтобы увидеть разницу, вот небольшой пример:

// Префиксная форма возвращает новое значение
counter = 1
console.log('counter = 1')
console.log('++counter', ++counter)
console.log('counter', counter)

// Постфиксная форма возвращает старое значение
counter = 1
console.log('counter = 1')
console.log('counter++', counter++)
console.log('counter', counter)

// !Если результат оператора не используется, а нужно только увеличить/уменьшить переменную, тогда без разницы, какую форму использовать. Обычно используется именно так

counter++

// let a = +(prompt("Первое число?", '1') as string)
//     a = Number(prompt("Первое число?", '1'))
//     a = parseInt(prompt("Первое число?", '1') as string)
//     a = parseFloat(prompt("Первое число?", '1') as string)

// !Операторы сравнения
// Многие операторы сравнения известны нам из математики.

// В JavaScript они записываются так:

// Больше / меньше: a > b, a < b.
// Больше / меньше или равно: a >= b, a <= b.
// Равно: a == b.Обратите внимание, для сравнения используется двойной знак равенства ==.Один знак равенства a = b означал бы присваивание.
// Не равно.В математике обозначается символом ≠, но в JavaScript записывается как a != b.
// В этом разделе мы больше узнаем про то, какие бывают сравнения, как язык с ними работает и к каким неожиданностям мы должны быть готовы.

// Результат сравнения имеет логический тип
// Все операторы сравнения возвращают значение логического типа:

// true – означает «да», «верно», «истина».
// false – означает «нет», «неверно», «ложь».

console.log('2 > 1', 2 > 1)   // true (верно)
// @ts-ignore
console.log('2 == 1', 2 == 1) // false (неверно)
console.log('2 == 2', 2 == 2) // true (верно)
// @ts-ignore
console.log('2 != 1', 2 != 1) // true (верно)


// Сравнение строк
// Чтобы определить, что одна строка больше другой, JavaScript использует «алфавитный» или «лексикографический» порядок.

// Другими словами, строки сравниваются посимвольно.

console.log("'Я' > 'А'", 'Я' > 'А') // true
console.log("'Коты' > 'Кода'", 'Коты' > 'Кода') // true
console.log("'Сонный' > 'Сон'", 'Сонный' > 'Сон') // true
// Алгоритм сравнения двух строк довольно прост:

// Сначала сравниваются первые символы строк.
// Если первый символ первой строки больше(меньше), чем первый символ второй, то первая строка больше(меньше) второй.Сравнение завершено.
// Если первые символы равны, то таким же образом сравниваются уже вторые символы строк.
// Сравнение продолжается, пока не закончится одна из строк.
// Если обе строки заканчиваются одновременно, то они равны.Иначе, большей считается более длинная строка.
// В примерах выше сравнение 'Я' > 'А' завершится на первом шаге, тогда как строки 'Коты' и 'Кода' будут сравниваться посимвольно:

// К равна К.
// о равна о.
// т больше, чем д.На этом сравнение заканчивается.Первая строка больше.

// Используется кодировка Unicode, а не настоящий алфавит
// Приведённый выше алгоритм сравнения похож на алгоритм, используемый в словарях и телефонных книгах, но между ними есть и различия.

// Например, в JavaScript имеет значение регистр символов.Заглавная буква "A" не равна строчной "a".Какая же из них больше ? Строчная "a".Почему ? Потому что строчные буквы имеют больший код во внутренней таблице кодирования, которую использует JavaScript(Unicode).Мы ещё поговорим о внутреннем представлении строк и его влиянии в главе Строки.

// Сравнение разных типов
// При сравнении значений разных типов JavaScript приводит каждое из них к числу.

// @ts-ignore
console.log("'2' > 1", '2' > 1); // true, строка '2' становится числом 2
// @ts-ignore
console.log("'01' == 1", '01' == 1); // true, строка '01' становится числом 1
// Логическое значение true становится 1, а false – 0.

Например:

// @ts-ignore
console.log('true == 1', true == 1); // true
// @ts-ignore
console.log('false == 0', false == 0); // true
// Забавное следствие
// Возможна следующая ситуация:

// Два значения равны.
// Одно из них true как логическое значение, другое – false.

let a = 0
console.log('Boolean(a=0)', Boolean(a)) // false

let b = "0"
console.log('Boolean(b="0")', Boolean(b)) // true

// @ts-ignore
console.log('a == b', a == b) // true!
// С точки зрения JavaScript, результат ожидаем.Равенство преобразует значения, используя числовое преобразование, поэтому "0" становится 0. В то время как явное преобразование с помощью Boolean использует другой набор правил.

// !Строгое сравнение
// Использование обычного сравнения == может вызывать проблемы.Например, оно не отличает 0 от false
// !Сравнивает и значения и типы
// Оператор строгого равенства === проверяет равенство без приведения типов

// !Сравнение с null и undefined
// Поведение null и undefined при сравнении с другими значениями — особое:

// При строгом равенстве ===
// Эти значения различны, так как различны их типы.

console.log(null === undefined); // false
// При нестрогом равенстве ==
// Эти значения равны друг другу и не равны никаким другим значениям.Это специальное правило языка.

console.log(null == undefined); // true
// При использовании математических операторов и других операторов сравнения<> <= >=
// Значения null / undefined преобразуются к числам: null становится 0, а undefined – NaN.

// Посмотрим, какие забавные вещи случаются, когда мы применяем эти правила.И, что более важно, как избежать ошибок при их использовании.

// Странный результат сравнения null и 0
// Сравним null с нулём:

// @ts-ignore
console.log(null > 0);  // (1) false
console.log(null == 0); // (2) false
// @ts-ignore
console.log(null >= 0); // (3) true

// С точки зрения математики это странно.Результат последнего сравнения говорит о том, что "null больше или равно нулю", тогда результат одного из сравнений выше должен быть true, но они оба ложны.

// Причина в том, что нестрогое равенство и сравнения > < >= <= работают по - разному.Сравнения преобразуют null в число, рассматривая его как 0. Поэтому выражение(3) null >= 0 истинно, а null > 0 ложно.

// С другой стороны, для нестрогого равенства == значений undefined и null действует особое правило: эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому.Поэтому(2) null == 0 ложно.

// Несравненное значение undefined
// Значение undefined несравнимо с другими значениями:

// @ts-ignore
console.log(undefined > 0); // false (1)
// @ts-ignore
console.log(undefined < 0); // false (2)
console.log(undefined == 0); // false (3)
// Почему же сравнение undefined с нулём всегда ложно ?

// На это есть следующие причины:

// Сравнения(1) и(2) возвращают false, потому что undefined преобразуется в NaN, а NaN – это специальное числовое значение, которое возвращает false при любых сравнениях.
// Нестрогое равенство(3) возвращает false, потому что undefined равно только null, undefined и ничему больше.
// Как избежать проблем
// Зачем мы рассмотрели все эти примеры ? Должны ли мы постоянно помнить обо всех этих особенностях ? Не обязательно.Со временем все они станут вам знакомы, но можно избежать проблем, если следовать надёжным правилам:

// Относитесь очень осторожно к любому сравнению с undefined / null, кроме случаев строгого равенства ===.
// Не используйте сравнения >= > < <= с переменными, которые могут принимать значения null / undefined, разве что вы полностью уверены в том, что делаете.Если переменная может принимать эти значения, то добавьте для них отдельные проверки.

// ?Итого
// Операторы сравнения возвращают значения логического типа.
// Строки сравниваются посимвольно в лексикографическом порядке.
// Значения разных типов при сравнении приводятся к числу.Исключением является сравнение с помощью операторов строгого равенства / неравенства.
// Значения null и undefined равны == друг другу и не равны любому другому значению.
// Будьте осторожны при использовании операторов сравнений вроде > и < с переменными, которые могут принимать значения null / undefined.Хорошей идеей будет сделать отдельную проверку на null / undefined.


// !Инструкция «if»
// Инструкция if (...) вычисляет условие в скобках и, если результат true, то выполняет блок кода.
// Преобразование к логическому типу
// ?Инструкция if (…) вычисляет выражение в скобках и преобразует результат к логическому типу.
// !Число 0, пустая строка "", null, undefined и NaN становятся false. Из-за этого их называют «ложными» («falsy») значениями.
// !Остальные значения становятся true, поэтому их называют «правдивыми» («truthy»).

let year = 2014

// Одна проверка, один резултат. Записывается в одну строку
if (year == 2015) console.log('Вы правы!')

// year = prompt('В каком году была опубликована спецификация ECMAScript-2015?', '')
// Если в результате проверки должны выполниться какие-то инструкции, используем конструкцию if...else
if (year == 2015) {
  console.log('Да вы знаток!')
} else {
  console.log('А вот и неправильно!') // любое значение, кроме 2015
}
// Если в результате проверки хотим что-то присвоить какой-то переменной, используем конструкцию тернарный оператор
let result = (year == 2015) ? 'Да вы знаток!' : 'А вот и неправильно!'
console.log('result', result)


// Сработать может только одно условие. Код эттого условия выполнится и исполнение программы перейдёт к концу условного оператора
// Обязательная часть кода
if (year < 1015) {
  console.log('Это ОЧЕНЬ рано...')
  // Необязательная часть кода. Может повторяться для разных условий сколько угодно раз
} else if (year < 2015) {
  console.log('Это слишком рано')
} else if (year > 2015) {
  console.log('Это поздновато')
} else if (year > 3015) {
  console.log('Вряд ли')
  // Необязательная часть кода. Может применяться только раз. Сработает, если всё, что было выше не сработало
} else {
  console.log('Верно!')
}

// Сюда попадаем, если выполнилось ходь одно условие или else

// !Условный оператор „?“
// Иногда нам нужно определить переменную в зависимости от условия.

let accessAllowed
// age = +(prompt('Сколько вам лет?', '') as string)

if (age > 18) {
  accessAllowed = true
} else {
  accessAllowed = false
}

console.log(accessAllowed)
// Так называемый «условный» оператор «вопросительный знак» позволяет нам сделать это более коротким и простым способом.
// Оператор представлен знаком вопроса?.Его также называют «тернарный», так как этот оператор, единственный в своём роде, имеет три аргумента.

// let result = условие ? значение1 : значение2;

// Сначала вычисляется условие: если оно истинно, тогда возвращается значение1, в противном случае – значение2.

accessAllowed = (age > 18) ? true : false

// Технически, мы можем опустить круглые скобки вокруг age > 18. Оператор вопросительного знака имеет низкий приоритет, поэтому он выполняется после сравнения >.
// оператор сравнения "age > 18" выполняется первым в любом случае
// (нет необходимости заключать его в скобки)
accessAllowed = age > 18 ? true : false
// Но скобки делают код более простым для восприятия, поэтому мы рекомендуем их использовать.

// ?В примере выше вы можете избежать использования оператора вопросительного знака ?, т.к.сравнение само по себе уже возвращает true / false:

// то же самое
accessAllowed = age > 18


// !Несколько операторов „?“
// Последовательность операторов вопросительного знака ? позволяет вернуть значение, которое зависит от более чем одного условия.

age = 18

message = (age < 3) ? 'Здравствуй, малыш!' :
  (age < 18) ? 'Привет!' :
    (age < 100) ? 'Здравствуйте!' :
      'Какой необычный возраст!'

console.log(message);
// Поначалу может быть сложно понять, что происходит.Но при ближайшем рассмотрении мы видим, что это обычная последовательная проверка:

// Первый знак вопроса проверяет age < 3.
// Если верно – возвращает 'Здравствуй, малыш!'.В противном случае, проверяет выражение после двоеточия „:“, вычисляет age < 18.
// Если это верно – возвращает 'Привет!'.В противном случае, проверяет выражение после следующего двоеточия „:“, вычисляет age < 100.
// Если это верно – возвращает 'Здравствуйте!'.В противном случае, возвращает выражение после последнего двоеточия – 'Какой необычный возраст!'.
// Вот как это выглядит при использовании if..else:

if (age < 3) {
  message = 'Здравствуй, малыш!';
} else if (age < 18) {
  message = 'Привет!';
} else if (age < 100) {
  message = 'Здравствуйте!';
} else {
  message = 'Какой необычный возраст!';
}

// ?При чтении глаза сканируют код по вертикали.Блоки кода, занимающие несколько строк, воспринимаются гораздо легче, чем длинный горизонтальный набор инструкций.
// !Смысл оператора «вопросительный знак» ? – вернуть то или иное значение, в зависимости от условия.Пожалуйста, используйте его именно для этого.Когда вам нужно выполнить разные ветви кода – используйте if.

// !Конструкция "switch"
// Конструкция switch заменяет собой сразу несколько if.

// Она представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами.

// Синтаксис
// Конструкция switch имеет один или более блок case и необязательный блок default.

// Выглядит она так:

// switch (x) {
//   case 'value1':  // if (x === 'value1')
//     ...
//     [break]

//   case 'value2':  // if (x === 'value2')
//     ...
//     [break]

//   default:
//     ...
//     [break]
// }
// Переменная x проверяется на строгое равенство первому значению value1, затем второму value2 и так далее.
// Если соответствие установлено – switch начинает выполняться от соответствующей директивы case и далее, до ближайшего break (или до конца switch).
// Если ни один case не совпал – выполняется(если есть) вариант default.
// a = 2+2
a = 1

// break - обязательная инструкция, если мы не хотим, чтобы исполнилось всё подряд

switch (a) {
  case 1: // (a===1)
    console.log('Маловато 1')
    break
  case 2: // (a===2)
    console.log('Маловато 2')
    break
  case 3: // (a===3)
    console.log('Маловато 3')
    break
  case 4: // (a===4)
    console.log('В точку!')
    break
  case 5: // (a===5)
    console.log('Перебор')
    break
  default: // Если ничего не совпало
    console.log("Нет таких значений")
}

// Здесь оператор switch последовательно сравнит a со всеми вариантами из case.

// Сначала 3, затем – так как нет совпадения – 4. Совпадение найдено, будет выполнен этот вариант, со строки alert('В точку!') и далее, до ближайшего break, который прервёт выполнение.

// Если break нет, то выполнение пойдёт ниже по следующим case, при этом остальные проверки игнорируются.

// || (ИЛИ)
// Оператор «ИЛИ» выглядит как двойной символ вертикальной черты:

// result = a || b;
// Традиционно в программировании ИЛИ предназначено только для манипулирования булевыми значениями: в случае, если какой - либо из аргументов true, он вернёт true, в противоположной ситуации возвращается false.

// В JavaScript, как мы увидим далее, этот оператор работает несколько иным образом.Но давайте сперва посмотрим, что происходит с булевыми значениями.

// Существует всего четыре возможные логические комбинации:

console.log('true || true', true || true);   // true
console.log('false || true', false || true);  // true
console.log('true || false', false || true);  // true
console.log('false || false', false || true); // false

// Как мы можем наблюдать, результат операций всегда равен true, за исключением случая, когда оба аргумента false.

// Если значение не логического типа, то оно к нему приводится в целях вычислений.

//   Например, число 1 будет воспринято как true, а 0 – как false:

if (1 || 0) { // работает как if( true || false )
  console.log('truthy!');
}
// Обычно оператор || используется в if для проверки истинности любого из заданных условий.

// К примеру:

let hour = 9;

if (hour < 10 || hour > 18) {
  console.log('Офис закрыт.');
}
// Можно передать и больше условий:

hour = 12;
let isWeekend = true;

if (hour < 10 || hour > 18 || isWeekend) {
  console.log('Офис закрыт.'); // это выходной
}

// !ИЛИ "||" находит первое истинное значение
// Описанная выше логика соответствует традиционной.Теперь давайте поработаем с «дополнительными» возможностями JavaScript.

// Расширенный алгоритм работает следующим образом.

// При выполнении ИЛИ || с несколькими значениями:

// result = value1 || value2 || value3;
// Оператор || выполняет следующие действия:

// ?1 Вычисляет операнды слева направо.
// ?2 Каждый операнд конвертирует в логическое значение.Если результат true, останавливается и возвращает исходное значение этого операнда.
// ?3 Если все операнды являются ложными(false), возвращает последний из них.
// ?4 Значение возвращается в исходном виде, без преобразования.

// Другими словами, цепочка ИЛИ || возвращает первое истинное значение или последнее, если такое значение не найдено.

console.log('1 || 0', 1 || 0) // 1
console.log("true || 'no matter what'", true || 'no matter what'); // true

console.log('null || 1', null || 1); // 1 (первое истинное значение)
console.log('null || 0 || 1', null || 0 || 1); // 1 (первое истинное значение)
console.log('undefined || null || 0', undefined || null || 0); // 0 (поскольку все ложно, возвращается последнее значение)
// Это делает возможным более интересное применение оператора по сравнению с «чистым, традиционным, только булевым ИЛИ».

// && (И)
// Оператор И пишется как два амперсанда &&:

// result = a && b;
// В традиционном программировании И возвращает true, если оба аргумента истинны, а иначе – false:

console.log('true && true', true && true);   // true
console.log('false && true', false && true);  // false
console.log('true && false', true && false);  // false
console.log('false && false', false && false); // false


hour = 12;
let minute = 30;

if (hour == 12 && minute == 30) {
  console.log('The time is 12:30');
}
// Как и в случае с ИЛИ, любое значение допускается в качестве операнда И:

if (1 && 0) { // вычисляется как true && false
  alert("не сработает, так как результат ложный");
}

// !И «&&» находит первое ложное значение
// При нескольких подряд операторах И:

// result = value1 && value2 && value3;
// Оператор && выполняет следующие действия:

// ?1 Вычисляет операнды слева направо.
// ?2 Каждый операнд преобразует в логическое значение.Если результат false, останавливается и возвращает исходное значение этого операнда.
// ?3 Если все операнды были истинными, возвращается последний.
// ?4 Другими словами, И возвращает первое ложное значение.Или последнее, если ничего не найдено.

// Вышеуказанные правила схожи с поведением ИЛИ.Разница в том, что И возвращает первое ложное значение, а ИЛИ –  первое истинное.

// Если первый операнд истинный,
// И возвращает второй:
console.log('1 && 0', 1 && 0); // 0
console.log('1 && 5', 1 && 5); // 5

// Если первый операнд ложный,
// И возвращает его. Второй операнд игнорируется
console.log('null && 5', null && 5); // null
console.log('0 && "no matter what"', 0 && "no matter what"); // 0
// Можно передать несколько значений подряд.В таком случае возвратится первое «ложное» значение, на котором остановились вычисления.

console.log('1 && 2 && null && 3', 1 && 2 && null && 3); // null
// Когда все значения верны, возвращается последнее

console.log('1 && 2 && 3', 1 && 2 && 3); // 3
// Приоритет оператора && больше, чем у ||
// Приоритет оператора И && больше, чем ИЛИ ||, так что он выполняется раньше.

// Таким образом, код a && b || c && d по существу такой же, как если бы выражения && были в круглых скобках: (a && b) || (c && d).

// !(НЕ)
// Оператор НЕ представлен восклицательным знаком!.

// Синтаксис довольно прост:

// result = !value;
// Оператор принимает один аргумент и выполняет следующие действия:

// Сначала приводит аргумент к логическому типу true / false.
// Затем возвращает противоположное значение.

console.log('!true', !true); // false
console.log('!0', !0); // true
// В частности, двойное НЕ!! используют для преобразования значений к логическому типу:

console.log('!!"non-empty string"', !!"non-empty string"); // true
console.log('!!null', !!null); // false
// То есть первое НЕ преобразует значение в логическое значение и возвращает обратное, а второе НЕ снова инвертирует его.В конце мы имеем простое преобразование значения в логическое.

// Есть немного более подробный способ сделать то же самое – встроенная функция Boolean:

console.log('Boolean("non-empty string")', Boolean("non-empty string")); // true
console.log('Boolean(null)', Boolean(null)); // false
// Приоритет НЕ! является наивысшим из всех логических операторов, поэтому он всегда выполняется первым, перед && или ||.

// !Оператор нулевого слияния(??)
// Новая возможность
// Эта возможность была добавлена в язык недавно.В старых браузерах может понадобиться полифил.
// Оператор нулевого слияния представляет собой два вопросительных знака ??.

// Так как он обрабатывает null и undefined одинаковым образом, то для этой статьи мы введём специальный термин.Для краткости будем говорить, что значение «определено», если оно не равняется ни null, ни undefined.

// ?Результат выражения a ?? b будет следующим:
// ?если a определено, то a,
// ?если a не определено, то b.

// Иначе говоря, оператор ?? возвращает первый аргумент, если он не null / undefined, иначе второй.

// Оператор нулевого слияния не является чем - то принципиально новым.Это всего лишь удобный синтаксис, как из двух значений получить одно, которое «определено».

// Вот как можно переписать выражение result = a ?? b, используя уже знакомые нам операторы:

// result = (a !== null && a !== undefined) ? a : b;
// Теперь должно быть абсолютно ясно, что делает ??.Давайте посмотрим, где это может быть полезно.

// Как правило, оператор ?? нужен для того, чтобы задать значение по умолчанию для потенциально неопределённой переменной.

// Например, здесь мы отобразим user, если её значение не null / undefined, в противном случае Аноним:

user;

console.log(user ?? "Аноним"); // Аноним (user не существует)
// А вот пример, когда user присвоено значение:

user = "Иван";

console.log(user ?? "Аноним"); // Иван (user существует)
// Кроме этого, можно записать последовательность из операторов ??, чтобы получить первое значение из списка, которое не является null / undefined.

// Допустим, у нас есть данные пользователя в переменных firstName, lastName или nickName.Все они могут не существовать, если пользователь решил не вводить соответствующие значение.

// Мы хотели бы отобразить имя пользователя, используя одну из этих переменных, или показать «Аноним», если все они null / undefined.

// Для этого воспользуемся оператором ??:

let firstName = null;
let lastName = null;
let nickName = "Суперкодер";

// показывает первое значение, которое определено:
console.log(firstName ?? lastName ?? nickName ?? "Аноним"); // Суперкодер

// ! Единственное отличие от || в том, что ?? считает ложью только null и undefined

// !Приоритет оператора ?? такой же, как и у ||.Они оба равны 3 в таблице на MDN.

// Использование ?? вместе с && или ||
// По соображениям безопасности JavaScript запрещает использование оператора ?? вместе с && и ||, если приоритет явно не указан при помощи круглых скобок.

// Выполнение следующего кода приведёт к синтаксической ошибке:

// let x = 1 && 2 ?? 3; // Синтаксическая ошибка

// Это, безусловно, спорное ограничение было добавлено в спецификацию языка с целью избежать программные ошибки, когда люди начнут переходить с || на ??.

// Используйте скобки, чтобы обойти это ограничение:

x = (1 && 2) ?? 3; // Работает без ошибок

// Итого
// Оператор нулевого слияния ?? — это быстрый способ выбрать первое «определённое» значение из списка.

// Используется для присвоения переменным значений по умолчанию:

// будет height=100, если переменная height равна null или undefined
// height = height ?? 100;
// Оператор ?? имеет очень низкий приоритет, лишь немного выше, чем у ? и =, поэтому при использовании его в выражении, скорее всего, потребуются скобки.

// Запрещено использовать вместе с || или && без явно указанного приоритета, то есть без скобок.


// !Методы примитивов
// JavaScript позволяет нам работать с примитивными типами данных – строками, числами и т.д., как будто они являются объектами.У них есть и методы.Мы изучим их позже, а сначала разберём, как это всё работает, потому что, конечно, примитивы – не объекты.

// Давайте взглянем на ключевые различия между примитивами и объектами.

// Примитив

// Это – значение «примитивного» типа.
// ?Есть 7 примитивных типов: string, number, boolean, symbol, null, undefined и bigint.

// Объект

// Может хранить множество значений как свойства.
// Объявляется при помощи фигурных скобок { }, например: { name: "Рома", age: 30 }. В JavaScript есть и другие виды объектов: например, функции тоже являются объектами.

// Примитив как объект
// Вот парадокс, с которым столкнулся создатель JavaScript:

// !Есть много всего, что хотелось бы сделать с примитивами, такими как строка или число.Было бы замечательно, если бы мы могли обращаться к ним при помощи методов.
// !Примитивы должны быть лёгкими и быстрыми насколько это возможно.
// Выбранное решение, хотя выглядит оно немного неуклюже:

// ?Примитивы остаются примитивами.Одно значение, как и хотелось.
// ?Язык позволяет осуществлять доступ к методам и свойствам строк, чисел, булевых значений и символов.
// ?Чтобы это работало, при таком доступе создаётся специальный «объект - обёртка», который предоставляет нужную функциональность, а после удаляется.
// !Каждый примитив имеет свой собственный «объект - обёртку», которые называются: String, Number, Boolean, Symbol и BigInt.Таким образом, они имеют разный набор методов.

// К примеру, существует метод str.toUpperCase(), который возвращает строку в верхнем регистре.

// Вот, как он работает:

console.log('"Привет".toUpperCase()', "Привет".toUpperCase()) // ПРИВЕТ

// Очень просто, не правда ли ? Вот, что на самом деле происходит в str.toUpperCase():

// Строка str – примитив.В момент обращения к его свойству, создаётся специальный объект, который знает значение строки и имеет такие полезные методы, как toUpperCase().
// Этот метод запускается и возвращает новую строку(показывается в alert).
// !!!Специальный объект удаляется, оставляя только примитив str.
// ?Получается, что примитивы могут предоставлять методы, и в то же время оставаться «лёгкими».

// Движок JavaScript сильно оптимизирует этот процесс.Он даже может пропустить создание специального объекта.Однако, он всё же должен придерживаться спецификаций и работать так, как будто он его создаёт.

// Число имеет собственный набор методов.Например, toFixed(n) округляет число до n знаков после запятой.

console.log('1.24566.toFixed(2)', 1.24566.toFixed(2)) // 1.23

// !ЧИСЛА В JS

// Чтобы писать числа с большим количеством нулей:

// Используйте краткую форму записи чисел – "e", с указанным количеством нулей.Например: 123e6 это 123 с 6 - ю нулями 123000000.
// Отрицательное число после "e" приводит к делению числа на 1 с указанным количеством нулей.Например: 123e-6 это 0.000123(123 миллионных).
// ? Так же для записи числа можно использовать нижнее подчеркивание 100_000
// ? такое число везде будет вести себя как 100000

// Для других систем счисления:
// Можно записывать числа сразу в шестнадцатеричной(0x), восьмеричной(0o) и бинарной(0b) системах счисления
// parseInt(str, base) преобразует строку в целое число в соответствии с указанной системой счисления: 2 ≤ base ≤ 36.
// num.toString(base) представляет число в строковом виде в указанной системе счисления base.

// !Для проверки на NaN и Infinity:
// !isNaN(value) преобразует аргумент в число и проверяет, является ли оно NaN
// Number.isNaN(value) проверяет, является ли аргумент числом, и если да, то проверяет, является ли оно NaN
// !isFinite(value) преобразует аргумент в число и проверяет, что оно не является NaN / Infinity / -Infinity
// Number.isFinite(value) проверяет, является ли аргумент числом, и если да, то проверяет, что оно не является NaN / Infinity / -Infinity

// Для преобразования значений типа 12pt и 100px в число:
// !Используйте parseInt / parseFloat для «мягкого» преобразования строки в число, данные функции по порядку считывают число из строки до тех пор пока не возникнет ошибка.

// Для дробей:
// !Используйте округления Math.floor, Math.ceil, Math.trunc, Math.round или num.toFixed(precision).
// !!!!Помните, что при работе с дробями происходит потеря точности.

console.log('0.1 + 0.2 == 0.3', 0.1 + 0.2 == 0.3) // false
console.log('0.1 + 0.2', 0.1 + 0.2) // 0.30000000000000004

// наиболее надёжный способ обойти эту проблему,- это округлить результат используя метод toFixed(n):

console.log('+(0.1 + 0.2).toFixed(2)', +(0.1 + 0.2).toFixed(2)) // 0.30

// Ещё больше математических функций:
// Документация по объекту Math.Библиотека маленькая, но содержит всё самое важное.

function randomInteger(min: number, max: number) {
  return Math.floor(Math.random() * (max - min + 1) + min)
}

randomInteger(0, 5)


// Итого
// Есть три типа кавычек.Строки, использующие обратные кавычки, могут занимать более одной строки в коде и включать выражения ${… }.
// Строки в JavaScript кодируются в UTF - 16.
// Есть специальные символы, такие как разрыв строки \n.
// Для получения символа используйте[] или метод at.
// Для получения подстроки используйте slice или substring.
// Для того, чтобы перевести строку в нижний или верхний регистр, используйте toLowerCase / toUpperCase.
// Для поиска подстроки используйте indexOf или includes / startsWith / endsWith, когда надо только проверить, есть ли вхождение.
// Чтобы сравнить строки с учётом правил языка, используйте localeCompare.
// Строки также имеют ещё кое - какие полезные методы:

// str.trim() — убирает пробелы в начале и конце строки.
// str.repeat(n) — повторяет строку n раз.
// …и другие, которые вы можете найти в справочнике.
// Для строк предусмотрены методы для поиска и замены с использованием регулярных выражений.Но это отдельная большая тема, поэтому ей посвящена отдельная глава учебника Регулярные выражения.

// Также, на данный момент важно знать, что строки основаны на кодировке Юникод, и поэтому иногда могут возникать проблемы со сравнениями.Подробнее о Юникоде в главе Юникод, внутреннее устройство строк.

// ******  Циклы ******

// ?while - цикл с предусловием; Сначала проверяем условие, потом идём в тело цикла
// while (условие) { Тело цикла выполняется пока условие истинно, иначе управление переходит на следующую строку после цикла (цикл заканчивается)
//   Тело цикла
// }

let i = 1
let n1 = 5
console.log('Цикл while')
while (i <= n1) {
  console.log(i)
  i++
}

// 1. инициация итератора
// 2. проверка условия
// После проверки условия, если оно истинно, выполняется тело цикла. Если ложно,- выход
// 3. После каждого выполнения тела цикла делаем шаг итератора
// 4(2). проверка условия

// ?for (инициация итератора; условие; шаг итератора) {
//   Тело цикла
// }

// Выполнить начало
// → (Если условие == true → Выполнить тело, Выполнить шаг)
// → (Если условие == true → Выполнить тело, Выполнить шаг)
// → (Если условие == true → Выполнить тело, Выполнить шаг)
// → ...

console.log('Цикл for')
for (let i = 1; i <= n1; i++) {
  console.log(i)
}

// Бесконечный цикл с условием выхода
i=0
while (true) {
  if (i > 500) break
  // if(i%100==0) continue
  i+=50
  if(i%100==0) continue
  console.log(i)
}

// ?do while - цикл с постусловием; Сначала выполняем тело цикла, потом проверяем условие
// do {
//   Тело цикла
// } while (Условие) Тело цикла выполняется пока условие истинно, иначе управление переходит на следующую строку после цикла (цикл заканчивается)

// let number1
// do {
//   // @ts-ignore
//   number1 = +prompt('Введи число больше 0')
// } while (!number1 || number1<=0)

// alert(`количество 0 = ${n1}
// количество положительных 2
// `)

// Вариант с меткой
// outer: for (let i = 0; i < 3; i++) {
//   for (let j = 0; j < 3; j++) {
//     let input = prompt(`Значение на координатах (${i},${j})`, '');
//     // если пустая строка или Отмена, то выйти из обоих циклов
//     if (!input) break outer; // (*)
//     // сделать что-нибудь со значениями...
//   }
// }

// Директива continue также может быть использована с меткой.В этом случае управление перейдёт на следующую итерацию цикла с меткой

// Вариант с флагом
// let stopOuter = false // (Флаг)
// for (let i = 0; i < 3; i++) {
//   if (stopOuter) break
//   for (let j = 0; j < 3; j++) {
//     let input = prompt(`Значение на координатах (${i},${j})`, '');
//     // если пустая строка или Отмена, то выйти из обоих циклов
//     if (!input) {
//       stopOuter = true
//       break
//     } // (*)
//     // сделать что-нибудь со значениями...
//   }
// }

// Чётные без %
// for (let i = 2; i < 11; i += 2) {
//   alert(i)
// }

// Вывести простые числа
// Натуральное число, большее 1, называется простым, если оно ни на что не делится, кроме себя и 1.
// Другими словами, n > 1 – простое, если при его делении на любое число кроме 1 и n есть остаток.
// Например, 5 это простое число, оно не может быть разделено без остатка на 2, 3 и 4.
// Напишите код, который выводит все простые числа из интервала от 2 до n.
// Для n = 10 результат должен быть 2, 3, 5, 7.
// P.S.Код также должен легко модифицироваться для любых других интервалов.

// const maxNumber = +(prompt('До какого числа искать простые') as string)
// console.log(`Простые числа до ${maxNumber}`)
// for (let i=2; i<maxNumber;i++) {
//   let isSimple = true
//   for (let j=2; j<i; j++) {
//     if (i%j==0) {
//       isSimple=false
//       break
//     }
//   }
//   if (isSimple) console.log(i)
// }

// console.log(`second`)
// outer:
// for (let i = 2; i < maxNumber; i++) {
//   for (let j = 2; j < i; j++) {
//     if (!(i % j)) continue outer
//   }
//   console.log(i)
// }


// !Цикл выполнятеся, пока условие истинно
// !Условие всегда автоматически преобразуется к булеву

// ? while(условие) {тело цикла}
// ? do {тело цикла} while(условие)
// ? for (начало, условие, шаг) {тело цикла}

while (false) {
  console.log('никогда не выполнится')
}
while (true) {
  console.log('выполнится только раз, т.к. дальше break')
  break
}

do {
  console.log('выполнится только раз, т.к. условие ложно')
} while (false)

console.log('do...while один раз исполнит тело цикла, даже если условите ложно')
i = 5
do {
  console.log(i)
  i++
} while (i < 4)

console.log('while никогда не исполнит тело цикла, если условите ложно')
i = 5
while (i < 3) {
  console.log(i)
  i++
}

for (let i = 0; i < 10; i += 2) {
  console.log(i)
}

for (let i = 0; i < 3; i++) {
  console.log('i', i)
  for (let j = 0; j < 3; j++) {
    console.log('   j', j)
  }
}

console.log('break')

for (let i = 0; i < 4; i++) {
  if (i == 2) break
  console.log('i', i)
}

console.log('continue')

for (let i = 0; i < 6; i++) {
  if (!(i % 2)) continue
  console.log('i', i)
}

// Вывести простые числа
// Натуральное число, большее 1, называется простым, если оно ни на что не делится, кроме себя и 1.
// Другими словами, n > 1 – простое, если при его делении на любое число кроме 1 и n есть остаток.
// Например, 5 это простое число, оно не может быть разделено без остатка на 2, 3 и 4.
// Напишите код, который выводит все простые числа из интервала от 2 до n.
// Для n = 10 результат должен быть 2, 3, 5, 7.
// P.S.Код также должен легко модифицироваться для любых других интервалов.

console.log('find simple')
n = 10
for (let i = 2; i <= n; i++) {
  // Предполагаем, что число простое
  let isSimple = true
  for (let j = 2; j < i; j++) {
    // Проверям, что число простое
    if (i % j == 0) {
      // Выяснили, что число не простое
      isSimple = false
      break
    }
  }
  // Если число простое, то выводим его
  if (isSimple) console.log(i)
}


console.log('find simple без флага')
n = 10
number: for (let i = 2; i <= n; i++) {
  for (let j = 2; j < i; j++) {
    console.log('i', i, 'j', j)
    // Проверям, что число простое
    if (i % j == 0) {
      // number - имя метки, которое мы придумали
      continue number
    }
  }
  console.log(i)
}

for (let i = 0; i < 'word'.length; i++) {
  console.log(i, 'word'[i])
}

for (let letter of 'word') {
  console.log(letter)
}


// let answer = true
// while (answer) {
//   let intNumb1 = parseFloat(prompt('Введите число/цифру, которое хотите вычислить', '12') as string)
//   let intSign = prompt('Введите знак, который будет вычислять', '+ - * /')
//   let intNumb2 = parseFloat(prompt('Введите число/цыфру, которое хотите вычислить', '12') as string)
//   let res = 0
//   switch (intSign) {
//     case '-':
//       res = intNumb1 - intNumb2
//       break
//     case '+':
//       res = intNumb1 + intNumb2
//       break
//     case '*':
//       res = intNumb1 * intNumb2
//       break
//     case '/':
//       res = intNumb1 / intNumb2
//       break
//   }
//   answer = confirm(`Результат ${res}. Посчитать что-нибудь ещё?`)
// }

// Запросить у пользователя число и на сколько цифр его
// сдвинуть.Сдвинуть цифры числа и вывести результат(если
// число 123456 сдвинуть на 2 цифры, то получится 345612).

let numStr = '123456'
let shift = 3

let newNumStr = ''
for (let i = shift; i < numStr.length; i++) {
  newNumStr += numStr[i]
  console.log(i, numStr[i], newNumStr)
}
for (let i = 0; i < shift; i++) {
  newNumStr += numStr[i]
  console.log(i, numStr[i], newNumStr)
}
console.log(+newNumStr)

// Запросить 2 числа и найти только наибольший общий делитель.

// let intNumb1 = Math.abs(parseFloat(prompt('Введите первое число, для нахождения общего делителя', '18') as string))
// let intNumb2 = Math.abs(parseFloat(prompt('Введите второе число, для нахождения общего делителя', '99') as string))

// // Меньее на большее ровно поделиться не может
// // Найдём, какое из чисел меньше

// let min = intNumb1 > intNumb2 ? intNumb2 : intNumb1

// if (intNumb1 > intNumb2) {
//   min = intNumb2
// } else {
//   min = intNumb1
// }

// // Нашли минимальное. Теперь посмотрим, на какие числа до минимального делятся оба без остатка
// // Все общие делители
// console.log('Все общие делители')
// for (let i = 1; i <= min; i++) {
//   if (intNumb1%i==0 && intNumb2%i==0) {
//     console.log(i)
//   }
// }
// console.log('Наибольший общий делитель')
// for (let i = min; i > 0; i--) {
//   if (intNumb1%i==0 && intNumb2%i==0) {
//     console.log(i)
//     break
//   }
// }

// let day = true;
// let nextDay = prompt('Напишите сегодняшний день, чтобы увидеть следующий', 'Пятница') as string;
// while (day) {

//   switch (nextDay) {
//     case 'Понедельник':
//       nextDay = 'Вторник'
//       break
//     case 'Вторник':
//       nextDay = 'Среда'
//       break
//     case 'Среда':
//       nextDay = 'Четверг'
//       break
//     case 'Четверг':
//       nextDay = 'Пятница'
//       break
//     case 'Пятница':
//       nextDay = 'Суббота'
//       break
//     case 'Суббота':
//       nextDay = 'Воскресенье'
//       break
//     case 'Воскресенье':
//       nextDay = 'Понедельник'
//       break
//     default:
//       nextDay = 'Понедельник'
// }

//   day = confirm(`Cледующий день ${nextDay}, хотите узнать следующий день?`);
// }


// !Функции

// function имя(параметры) {
//   ...тело...
// }

// Функция, объявленная церез ключевое слово function как бы всплывает в самый верх кода. Поэтому её можно вызвать в любом месте
showMessage1(1520) // Вызов функции

function showMessage1(stringNumber:number) {
  console.log('Всем привет из функции! Функция вызвана из строки', stringNumber)
  // функции имеют доступ к глобальным переменным
  console.log('global i', i)
}

showMessage1(1526) // Вызов функции
console.log(showMessage1) // выводится тело функции

// ! Функции всегда что-то возвращают. Если нет явного возврата значения, функция вернёт undefined
console.log(showMessage1(1530)) // undefined


// ! Область видимости

// ? Глобальная область видимости - это просто код, который мы писали везде до этого (кроме кода в фигурных скобках,-тело цикла, тело if/else, тело функции)
// Переменные, объявленные в глобальной области видимости дорступны везде
// Объявление переменной - это ключевые слова let, const, function

// ? Локальная область видимости - это код, внутри любых фигурных скобок
// Переменные, объявленные в локальной области видимости доступны в рамках фигурных скобок, в которых они объявлены, и во всех нижестоящих локальных уровнях
console.log('global i',i)
// здесь j объявляется в локальной области видимости цикла for
for (let j=0; j<2; j++) {
  console.log('j', j) // 0,1
  if (j==0) {
    console.log('j==0', j) // 0,1
    const z = 0
    console.log('z', z) 
    let i =0
    i++
    console.log('local i',i)
  }
  //console.log('z', z) //z is not defined
}
console.log('global i',i)

// перепишем for в while
// Обернул в if, который всегда сработает, чтобы создать локальную область видимости
if (true) {
  let j = 0
  while(j<2) {
    console.log('j', j) // 0,1
    j++
  }
}

// j не существует в глобальной области видимости. Не объявлена выше по коду
// console.log('j', j) //j is not defined

let j = 10 // переменная j объявлена и существует
console.log('j', j)


// !Параметры
// ?Мы можем передать внутрь функции любую информацию, используя параметры.
// В нижеприведённом примере функции передаются два параметра: from и text.

function showMessage(from:any, text='Многозначительно молчит...') { // параметры: from, text
  from = '*' + from + '*'; // немного украсим "from"
  console.log('local from', from);
  return
  console.log(from + ': ' + text);
}

showMessage('Аня', 'Привет!'); // *Аня*: Привет! (*)
showMessage('Аня', "Как дела?"); // *Аня*: Как дела? (**)
// Когда функция вызывается в строках(*) и(**), переданные значения копируются в локальные переменные from и text.Затем они используются в теле функции.

// Вот ещё один пример: у нас есть переменная from, и мы передаём её функции.Обратите внимание: функция изменяет значение from, но это изменение не видно снаружи.Функция всегда получает только копию значения:


let from = "Ваня";

showMessage(from, "Привет"); // *Ваня*: Привет
showMessage(from)

// значение "from" осталось прежним, функция изменила значение локальной переменной
console.log('global from',from) // Ваня

// Значение, передаваемое в качестве параметра функции, также называется аргументом.

// Параметр – это переменная, указанная в круглых скобках в объявлении функции.
// Аргумент – это значение, которое передаётся функции при её вызове.
// Мы объявляем функции со списком параметров, затем вызываем их, передавая аргументы.

// Рассматривая приведённый выше пример, мы могли бы сказать: "функция showMessage объявляется с двумя параметрами, затем вызывается с двумя аргументами: from и "Привет"".

function checkAge1(age:number) {
  if (age >= 18) {
    return true;
  } else {
    return confirm('А родители разрешили?');
  }
}
// Более короткий вариант записи 1
function checkAge2(age:number) {
  if (age >= 18) {
    return true;
  }
  return confirm('А родители разрешили?');
}
// Более короткий вариант записи 2
function checkAge3(age:number) {
  return (age >= 18) ? true : confirm('А родители разрешили?')
}

// Написать функцию, которая принимает 2 числа и знак (+ - * /), считает пример и возвращает результат.
function calc(n1=5, n2=8, sign='*') {
  switch (sign) {
    case '-':
      return n1-n2
    case '+':
      return n1+n2
    case '*':
      return n1*n2
    case '/':
      return n1/n2
  }
}

console.log("calc()", calc())
console.log("calc(2,6,'-')", calc(2,6,'-'))

// Написать функцию, которая принимает от 1 до 5 чисел и возвращает их сумму.
function getSum(n1:number,n2=0,n3=0,n4=0,n5=0) {
  return n1 + n2 + n3 + n4 + n5
}
getSum(1,2,5)

// TS-style Функция, которая может принять неограниченное количество переменных
function getNSum(n1:number,...args:any) {
  let sum = n1
  for (let i=0;i<args.length;i++) {
    sum+=args[i]
  }
  return sum
}

console.log(getNSum(1,5,8,9,4,7,65,4,5,8,46,698,46,65))

console.log(getNSum2(1))

// JS-style Функция, которая может принять неограниченное количество переменных
function getNSum2(n1: number, ...args: any) {
  console.log(arguments) // массив всех значений, которые пришли в функцию
  console.log(args)      // args - общепринятое именование для дополнительных параметров функции
  // тоже является массивом, но в него попадут только те аргументы, которые переданы сверх именованных
  
  let sum = 0
  for (let i = 0; i < arguments.length; i++) {
    sum += arguments[i]
  }
  return sum
}

console.log(getNSum2(1, 5,6))
